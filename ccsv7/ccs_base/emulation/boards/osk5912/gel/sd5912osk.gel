/*--------------------------------------------------------------*/
/* SD5912OSK.gel                                                */
/* Version 3.00                                                 */
/*                                                              */
/* This GEL file is designed to be used in conjunction with     */
/* CCS 3.X and the OMAP5912 based OSK.                          */
/*                                                              */
/*--------------------------------------------------------------*/

/*--------------------------------------------------------------*/
/* StartUp()                                                    */
/* This function is called each time CCS is started.            */
/* Customize this function to perform desired initialization.   */
/*--------------------------------------------------------------*/
StartUp()
{
    setup_memory_map();

    /*------------------------------------------------------*/
    /* Uncomment the OnTargetConnect() call for CCS 2.X     */
    /* support.                                             */
    /*                                                      */
    /*                                                      */
    /*------------------------------------------------------*/
    //OnTargetConnect();
}

/*--------------------------------------------------------------*/
/* OnTargetConnect()                                            */
/* This function is called by CCS when you do Debug->Connect on */
/* CCS 3.X.  When using CCS 2.X, the OnTargetConnect() call     */
/* should be uncommented from the StartUp() function.           */
/*--------------------------------------------------------------*/
OnTargetConnect()
{
    /* Quick setup ( retains the current state ) */
    if ( 0 )
    {
        disable_watchdog_timer( );      // Stop the Watchdog timer
    }
    /* Normal setup ( reset and then set to a known state ) */
    else
    {
        /*------------------------------------------------------*/
        /* GEL_Reset() is used to deal with the worst case      */
        /* senario of unknown target state.  If for some reason */
        /* a reset is not desired upon target connection,       */
        /* GEL_Reset() may be removed and replaced with         */
        /* something "less brutal" like a cache initialization  */
        /* function.                                            */
        /*------------------------------------------------------*/
        GEL_Reset();

        disable_watchdog_timer( );      // Stop the Watchdog timer
        init_emif( );                   // Configure EMIFS & EMIFF
        init_pll( 192 );                // Configure DPLL & Clocks
        setup_pin_mux( );               // Configure Pin Mux
        setup_peripherals( );           // Configure Peripherals
        release_dsp_from_reset( );      // Release DSP from reset
    }

    GEL_TextOut( "GEL StartUp Complete.\n" );
}

/*--------------------------------------------------------------*/
/* OnReset()                                                    */
/* This function is called by CCS when you do Debug->Resest.    */
/* The goal is to put the OMAP into a known good state with     */
/* respect to cache and interrupts.                             */
/*--------------------------------------------------------------*/
OnReset( int nErrorCode )
{
    reset_arm( );
}

/*--------------------------------------------------------------*/
/* OnRestart()                                                  */
/* This function is called by CCS when you do Debug->Restart.   */
/* The goal is to put the OMAP into a known good state with     */
/* respect to cache and interrupts.                             */
/*--------------------------------------------------------------*/
OnRestart( )
{
    int pc_save = PC;

    /* Switch from Thumb Mode to ARM Mode if needed */
    if ( ( CPSR & 0x20 ) == 0x20 )
	{
        GEL_Reset();
		PC = pc_save;
    }
	else
	{
        CPSR = 0x400000D3;          // Set CPSR to supervisor mode, disable IRQ/FIQ
        REG_CP15_FLSH_DI;           // Flush then disable D-Cache & I-Cache
        REG_CP15_I_CACHE = 0;
        REG_CP15_D_CACHE = 0;
        REG_CP15_MMU = 0;           // Disable MMU
        PC = pc_save;
    }
}

/*--------------------------------------------------------------*/
/* OnPreFileLoaded()                                            */
/* This function is called automatically when the 'Load Program'*/
/* Menu item is selected.                                       */
/*--------------------------------------------------------------*/
OnPreFileLoaded( )
{
    reset_arm( );
}

/*--------------------------------------------------------------*/
/* setup_memory_map()                                           */
/* Memory map setup                                             */
/*--------------------------------------------------------------*/
setup_memory_map()
{
    GEL_MapOn();
    GEL_MapReset( );

    /* Memory Blocks */
    GEL_MapAddStr( 0x00000000, 0, 0x04000000, "R|W|AS4", 0 ); // CS0: Flash 64MB
    GEL_MapAddStr( 0x04800000, 0, 0x00800000, "R|W|AS2", 0 ); // CS1A: ENET
    GEL_MapAddStr( 0x08000000, 0, 0x00004000, "R|W|AS2", 0 ); // CS2A: CFlash
    GEL_MapAddStr( 0x0C000000, 0, 0x04000000, "R|W|AS4", 0 ); // CS3: Flash 64MB
    GEL_MapAddStr( 0x10000000, 0, 0x04000000, "R|W|AS4", 0 ); // SDRAM: 64MB
    GEL_MapAddStr( 0x20000000, 0, 0x0003E800, "R|W|AS4", 0 ); // SRAM: 250KB

    /* DSP Memory Block */
    GEL_MapAddStr( 0xE0000000, 0, 0x01000000, "R|W|AS4", 0 ); // MPUI Memory

    /* DSP Strobe 0 */
    GEL_MapAddStr( 0xE1000000, 0, 0x0012, "R|W|AS2", 0 ); // DSP RHEA
    GEL_MapAddStr( 0xE1008000, 0, 0x0020, "R|W|AS2", 0 ); // DSP CLKM

    /* DSP Strobe 1 */
    GEL_MapAddStr( 0xE1010000, 0, 0x0060, "R|W|AS1", 0 ); // UART1
    GEL_MapAddStr( 0xE1010800, 0, 0x0060, "R|W|AS1", 0 ); // UART2
    GEL_MapAddStr( 0xE1010C00, 0, 0x0040, "R|W|AS2", 0 ); // SPI
    GEL_MapAddStr( 0xE1011000, 0, 0x0040, "R|W|AS2", 0 ); // McBSP2
    GEL_MapAddStr( 0xE1011400, 0, 0x0044, "R|W|AS2", 0 ); // GPTIMER1
    GEL_MapAddStr( 0xE1011800, 0, 0x0040, "R|W|AS2", 0 ); // McBSP1
    GEL_MapAddStr( 0xE1011C00, 0, 0x0044, "R|W|AS2", 0 ); // GPTIMER2
    GEL_MapAddStr( 0xE1012000, 0, 0x0080, "R|W|AS2", 0 ); // MCSI2
    GEL_MapAddStr( 0xE1012400, 0, 0x0044, "R|W|AS2", 0 ); // GPTIMER3
    GEL_MapAddStr( 0xE1012800, 0, 0x0080, "R|W|AS2", 0 ); // MCSI1
    GEL_MapAddStr( 0xE1012C00, 0, 0x0044, "R|W|AS2", 0 ); // GPTIMER4
    GEL_MapAddStr( 0xE1013400, 0, 0x0044, "R|W|AS2", 0 ); // GPTIMER5
    GEL_MapAddStr( 0xE1013800, 0, 0x0040, "R|W|AS2", 0 ); // I2C
    GEL_MapAddStr( 0xE1013800, 0, 0x0044, "R|W|AS2", 0 ); // GPTIMER6
    GEL_MapAddStr( 0xE1017000, 0, 0x0040, "R|W|AS2", 0 ); // McBSP3
    GEL_MapAddStr( 0xE1017400, 0, 0x0044, "R|W|AS2", 0 ); // GPTIMER7
    GEL_MapAddStr( 0xE1017C00, 0, 0x006C, "R|W|AS2", 0 ); // MMCSDIO2
    GEL_MapAddStr( 0xE1019800, 0, 0x0060, "R|W|AS1", 0 ); // UART3
    GEL_MapAddStr( 0xE101A400, 0, 0x0500, "R|W|AS2", 0 ); // STI
    GEL_MapAddStr( 0xE101B400, 0, 0x00F4, "R|W|AS2", 0 ); // GPIO3
    GEL_MapAddStr( 0xE101BC00, 0, 0x00F4, "R|W|AS2", 0 ); // GPIO4
    GEL_MapAddStr( 0xE101C400, 0, 0x0014, "R|W|AS2", 0 ); // 32k Sync Timer
    GEL_MapAddStr( 0xE101C800, 0, 0x00B4, "R|W|AS2", 0 ); // Rhea Switch
    GEL_MapAddStr( 0xE101CC00, 0, 0x007C, "R|W|AS2", 0 ); // NAND Flash Ctrl
    GEL_MapAddStr( 0xE101D400, 0, 0x0044, "R|W|AS2", 0 ); // GPTIMER8
    GEL_MapAddStr( 0xE101E400, 0, 0x00F4, "R|W|AS2", 0 ); // GPIO1
    GEL_MapAddStr( 0xE101EC00, 0, 0x00F4, "R|W|AS2", 0 ); // GPIO2
    GEL_MapAddStr( 0xE101F000, 0, 0x0030, "R|W|AS2", 0 ); // Mailbox
    GEL_MapAddStr( 0xE1020000, 0, 0x0004, "R|W|AS2", 0 ); // MGS3 MPUI Ctrl

    /* ARM Public TIPB Strobe 0 */
    GEL_MapAddStr( 0xFFFB0000, 0, 0x0060, "R|W|AS1", 0 ); // UART 1
    GEL_MapAddStr( 0xFFFB0400, 0, 0x0100, "R|W|AS4", 0 ); // USB OTG
    GEL_MapAddStr( 0xFFFB0800, 0, 0x0060, "R|W|AS1", 0 ); // UART 2
    GEL_MapAddStr( 0xFFFB0C00, 0, 0x0040, "R|W|AS4", 0 ); // SPI
    GEL_MapAddStr( 0xFFFB1000, 0, 0x0040, "R|W|AS2", 0 ); // McBSP2
    GEL_MapAddStr( 0xFFFB1400, 0, 0x0044, "R|W|AS4", 0 ); // GPTIMER1
    GEL_MapAddStr( 0xFFFB1C00, 0, 0x0044, "R|W|AS4", 0 ); // GPTIMER2
    GEL_MapAddStr( 0xFFFB2400, 0, 0x0044, "R|W|AS4", 0 ); // GPTIMER3
    GEL_MapAddStr( 0xFFFB2C00, 0, 0x0044, "R|W|AS4", 0 ); // GPTIMER4
    GEL_MapAddStr( 0xFFFB3000, 0, 0x001C, "R|W|AS2", 0 ); // uWire
    GEL_MapAddStr( 0xFFFB3400, 0, 0x0044, "R|W|AS4", 0 ); // GPTIMER5
    GEL_MapAddStr( 0xFFFB3800, 0, 0x0040, "R|W|AS2", 0 ); // I2C
    GEL_MapAddStr( 0xFFFB3C00, 0, 0x0044, "R|W|AS4", 0 ); // GPTIMER6
    GEL_MapAddStr( 0xFFFB4000, 0, 0x0100, "R|W|AS2", 0 ); // USB Client
    GEL_MapAddStr( 0xFFFB4800, 0, 0x0058, "R|W|AS2", 0 ); // RTC
    GEL_MapAddStr( 0xFFFB5000, 0, 0x0038, "R|W|AS2", 0 ); // MPUIO
    GEL_MapAddStr( 0xFFFB5800, 0, 0x0008, "R|W|AS2", 0 ); // PWL
    GEL_MapAddStr( 0xFFFB6000, 0, 0x000C, "R|W|AS2", 0 ); // PWT
    GEL_MapAddStr( 0xFFFB6800, 0, 0x002C, "R|W|AS4", 0 ); // CAMERA
    GEL_MapAddStr( 0xFFFB7400, 0, 0x0044, "R|W|AS4", 0 ); // GPTIMER7
    GEL_MapAddStr( 0xFFFB7800, 0, 0x006C, "R|W|AS2", 0 ); // MMC1/SDIO1
    GEL_MapAddStr( 0xFFFB7C00, 0, 0x006C, "R|W|AS2", 0 ); // MMC2/SDIO2
    GEL_MapAddStr( 0xFFFB8000, 0, 0x0400, "R|W|AS4", 0 ); // Memory Stick
    GEL_MapAddStr( 0xFFFB8C00, 0, 0x002C, "R|W|AS4", 0 ); // CCP
    GEL_MapAddStr( 0xFFFB9000, 0, 0x000C, "R|W|AS4", 0 ); // OS Timer
    GEL_MapAddStr( 0xFFFB9800, 0, 0x0060, "R|W|AS1", 0 ); // UART3
    GEL_MapAddStr( 0xFFFBA000, 0, 0x00F0, "R|W|AS4", 0 ); // USB Host
    GEL_MapAddStr( 0xFFFBA800, 0, 0x0010, "R|W|AS2", 0 ); // FAC
    GEL_MapAddStr( 0xFFFBAC00, 0, 0x0024, "R|W|AS4", 0 ); // SoSSI
    GEL_MapAddStr( 0xFFFBB400, 0, 0x00F4, "R|W|AS4", 0 ); // GPIO3
    GEL_MapAddStr( 0xFFFBBC00, 0, 0x00F4, "R|W|AS4", 0 ); // GPIO4
    GEL_MapAddStr( 0xFFFBC000, 0, 0x0010, "R|W|AS4", 0 ); // 1wire
    GEL_MapAddStr( 0xFFFBC400, 0, 0x0014, "R|W|AS4", 0 ); // 32K sync timer
    GEL_MapAddStr( 0xFFFBC800, 0, 0x0164, "R|W|AS4", 0 ); // TIPB switch
    GEL_MapAddStr( 0xFFFBCC00, 0, 0x007C, "R|W|AS4", 0 ); // NAND Flash ctrl
    GEL_MapAddStr( 0xFFFBD000, 0, 0x0008, "R|W|AS4", 0 ); // LPG1
    GEL_MapAddStr( 0xFFFBD400, 0, 0x0044, "R|W|AS4", 0 ); // GPTIMER8/32-KHz Synchro
    GEL_MapAddStr( 0xFFFBD800, 0, 0x0008, "R|W|AS4", 0 ); // LPG2
    GEL_MapAddStr( 0xFFFBE400, 0, 0x00F4, "R|W|AS4", 0 ); // GPIO1
    GEL_MapAddStr( 0xFFFBEC00, 0, 0x00F4, "R|W|AS4", 0 ); // GPIO2

    /* ARM Public Strobe 1 */
    GEL_MapAddStr( 0xFFFCF000, 0, 0x0030, "R|W|AS2", 0 ); // Mailbox

    /* ARM Private Strobe 0 */
    /* ARM Private Strobe 1 */
    GEL_MapAddStr( 0xFFFE0000, 0, 0x00AC, "R|W|AS4", 0 ); // MPU Intr Hndl 2
    GEL_MapAddStr( 0xFFFE0800, 0, 0x0054, "R|W|AS4", 0 ); // ULPD
    GEL_MapAddStr( 0xFFFE1000, 0, 0x0154, "R|W|AS4", 0 ); // OMAP5912 Config
    GEL_MapAddStr( 0xFFFE1800, 0, 0x0008, "R|W|AS4", 0 ); // Die ID
    GEL_MapAddStr( 0xFFFE2000, 0, 0x0008, "R|W|AS4", 0 ); // Production ID
    GEL_MapAddStr( 0xFFFE2800, 0, 0x0006, "R|W|AS4", 0 ); // Compact Flash
    GEL_MapAddStr( 0xFFFE3000, 0, 0x0088, "R|W|AS4", 0 ); // LCD Converter
    GEL_MapAddStr( 0xFFFE3800, 0, 0x0800, "R|W|AS4", 0 ); // BCM
    GEL_MapAddStr( 0xFFFE4000, 0, 0x0800, "R|W|AS4", 0 ); // DES/3DES
    GEL_MapAddStr( 0xFFFE4800, 0, 0x0800, "R|W|AS4", 0 ); // SHA-1/MD5
    GEL_MapAddStr( 0xFFFE5000, 0, 0x0800, "R|W|AS4", 0 ); // RNG
    GEL_MapAddStr( 0xFFFE5800, 0, 0x0800, "R|W|AS4", 0 ); // OMAP5912 JTAG
    GEL_MapAddStr( 0xFFFEA000, 0, 0x0800, "R|W|AS4", 0 ); // STI
    GEL_MapAddStr( 0xFFFEA800, 0, 0x0800, "R|W|AS4", 0 ); // Secure Watchdog
    GEL_MapAddStr( 0xFFFEB000, 0, 0x004C, "R|W|AS4", 0 ); // 32K Watchdog
    GEL_MapAddStr( 0xFFFEC000, 0, 0x0020, "R|W|AS4", 0 ); // LCD Controller
    GEL_MapAddStr( 0xFFFEC300, 0, 0x003C, "R|W|AS4", 0 ); // L3 OCPI
    GEL_MapAddStr( 0xFFFEC500, 0, 0x000C, "R|W|AS4", 0 ); // MPU Timer 1
    GEL_MapAddStr( 0xFFFEC600, 0, 0x000C, "R|W|AS4", 0 ); // MPU Timer 2
    GEL_MapAddStr( 0xFFFEC700, 0, 0x000C, "R|W|AS4", 0 ); // MPU Timer 3
    GEL_MapAddStr( 0xFFFEC800, 0, 0x000C, "R|W|AS4", 0 ); // WatchDog Timer
    GEL_MapAddStr( 0xFFFEC900, 0, 0x0028, "R|W|AS4", 0 ); // MPUI Interface
    GEL_MapAddStr( 0xFFFECA00, 0, 0x0024, "R|W|AS4", 0 ); // TIPB Bridge
    GEL_MapAddStr( 0xFFFECB00, 0, 0x00A4, "R|W|AS4", 0 ); // MPU Intr Hndl 1
    GEL_MapAddStr( 0xFFFECC00, 0, 0x00EC, "R|W|AS4", 0 ); // Traffic Ctrl
    GEL_MapAddStr( 0xFFFECE00, 0, 0x0028, "R|W|AS4", 0 ); // CLKM
    GEL_MapAddStr( 0xFFFECF00, 0, 0x0004, "R|W|AS2", 0 ); // DPLL1
    GEL_MapAddStr( 0xFFFED200, 0, 0x0058, "R|W|AS4", 0 ); // DSP MMU
    GEL_MapAddStr( 0xFFFED300, 0, 0x0020, "R|W|AS4", 0 ); // TIPB Bridge 2
    GEL_MapAddStr( 0xFFFED400, 0, 0x0100, "R|W|AS2", 0 ); // Test block PSA
    GEL_MapAddStr( 0xFFFED800, 0, 0x0484, "R|W|AS2", 0 ); // System DMA
}

/*--------------------------------------------------------------*/
/* clear_memory_map()                                           */
/* Memory map disable                                           */
/*--------------------------------------------------------------*/
clear_memory_map()
{
    GEL_MapOff();
}

/*--------------------------------------------------------------*/
/* init_emif()                                                  */
/* Emif initialization                                          */
/*--------------------------------------------------------------*/
init_emif()
{
    /*------------------------------------------------------*/
    /* Configure EMIFS                                      */
    /* Setup EMIFS for: NOR Flash, Comact Flash, & ENET     */
    /*------------------------------------------------------*/
    /* EMIFS registers */
    #define EMIFS_CONFIG            *( unsigned int* )0xFFFECC0C
    #define EMIFS_CCS0              *( unsigned int* )0xFFFECC10
    #define EMIFS_CCS1              *( unsigned int* )0xFFFECC14
    #define EMIFS_CCS2              *( unsigned int* )0xFFFECC18
    #define EMIFS_CCS3              *( unsigned int* )0xFFFECC1C

    /* Configure EMIFS ( slow external memory: Flash ) */
    EMIFS_CCS0 = 0x0000FFF3;        // Nothing
    EMIFS_CCS1 = 0x0000AAA0;        // Ethernet
    EMIFS_CCS2 = 0x0000FFF3;        // Compact Flash
    EMIFS_CCS3 = 0x00003361;        // Intel Flash

    /* Reset flash to Read Array Mode */
    if ( EMIFS_CONFIG & 2 )
        *( unsigned char* )0x00000000 = 0xFF;
    else
        *( unsigned char* )0x0C000000 = 0xFF;

    /*------------------------------------------------------*/
    /* Configure EMIFF                                      */
    /* Setup EMIFF for: SDRAM-Mobile DDR                    */
    /*------------------------------------------------------*/

    /* EMIFF registers */
    #define EMIFF_CONFIG            *( unsigned int* )0xFFFECC20
    #define EMIFF_DLL_WRD_CTRL      *( unsigned int* )0xFFFECC64
    #define EMIFF_MRS_NEW           *( unsigned int* )0xFFFECC70
    #define EMIFF_EMRS1             *( unsigned int* )0xFFFECC78
    #define EMIFF_OP                *( unsigned int* )0xFFFECC80
    #define EMIFF_CMD               *( unsigned int* )0xFFFECC84
    #define EMIFF_DLL_URD_CTRL      *( unsigned int* )0xFFFECCC0
    #define EMIFF_DLL_LRD_CTRL      *( unsigned int* )0xFFFECCCC

    /* -------------------------------------------------------- *
     *  Initialization procedures for SDRAM Mobile DDR          *
     * -------------------------------------------------------- */
    EMIFF_OP      = 0x00000007;     // Mobile DDR in Hi-Power/Hi-Bandwidth mode
    EMIFF_CONFIG  = 0x00173EFE;     // SDRAM Configuration
    EMIFF_CMD     = 0x00000000;     // NOP
    EMIFF_CMD     = 0x00000001;     // PRECHARGE
    EMIFF_CMD     = 0x00000002;     // AUTOREFRESH
    EMIFF_CMD     = 0x00000002;     // AUTOREFRESH
    EMIFF_MRS_NEW = 0x00000033;     // CAS idle 3, Page burst 8
    EMIFF_EMRS1   = 0;              // EMRS1 self refresh all banks

    EMIFF_DLL_URD_CTRL = 0x06;      // Enable DLL at 90 degree phase
    EMIFF_DLL_LRD_CTRL = 0x06;
    EMIFF_DLL_WRD_CTRL = 0x06;
}

/*--------------------------------------------------------------*/
/* init_pll()                                                   */
/* PLL initialization                                           */
/*--------------------------------------------------------------*/
init_pll( int freq )
{
    int en_dspck_state;

    /* PLL & CLK registers */
    #define DPLL1_CTL_REG           *( unsigned int* )0xFFFECF00
    #define ARM_CKCTL               *( unsigned int* )0xFFFECE00
    #define ARM_IDLECT1             *( unsigned int* )0xFFFECE04
    #define ARM_IDLECT2             *( unsigned int* )0xFFFECE08
    #define ARM_RSTCT1              *( unsigned int* )0xFFFECE10
    #define ARM_RSTCT2              *( unsigned int* )0xFFFECE14
    #define ARM_SYSST               *( unsigned int* )0xFFFECE18

    ARM_IDLECT2    |= 0x00000004;   // Enable ARM peripheral clock
    DPLL1_CTL_REG   = 0x00002090;   // Start DPLL lock at 12 MHz

    while( ! ( DPLL1_CTL_REG & 1 ) ); // Poll PLL until locked

    en_dspck_state = ARM_CKCTL & ( 1 << 13 ); // Save EN_DSPCK state

    /* Settings for 192 MHz freq */
    if ( freq == 192 )
    {
        ARM_SYSST     = 0x0000103F; // Set clocking mode: Synchronous Scalable
        ARM_CKCTL     = 0x0000110F  // Set the clock divisors
                      | en_dspck_state;
        DPLL1_CTL_REG = 0x00002810; // Set the DPLL to final frequency
    }
    /* Settings for 96 MHz freq */
    else if ( freq == 96 )
    {
        ARM_SYSST     = 0x0000003F; // Set clocking mode: Fully Synchronous
        ARM_CKCTL     = 0x0000100A  // Set the clock divisors
                      | en_dspck_state;
        DPLL1_CTL_REG = 0x00002410; // Set the DPLL to final frequency
    }
}

/*--------------------------------------------------------------*/
/* setup_pin_mux()                                              */
/* Setup pin mux for OSK5912                                    */
/*--------------------------------------------------------------*/
setup_pin_mux( )
{
    /* Pin Mux Registers */
    #define FUNC_MUX_CTRL_0         *( unsigned int* )0xFFFE1000
    #define FUNC_MUX_CTRL_1         *( unsigned int* )0xFFFE1004
    #define FUNC_MUX_CTRL_2         *( unsigned int* )0xFFFE1008
    #define COMP_MODE_CTRL_0        *( unsigned int* )0xFFFE100C
    #define FUNC_MUX_CTRL_3         *( unsigned int* )0xFFFE1010
    #define FUNC_MUX_CTRL_4         *( unsigned int* )0xFFFE1014
    #define FUNC_MUX_CTRL_5         *( unsigned int* )0xFFFE1018
    #define FUNC_MUX_CTRL_6         *( unsigned int* )0xFFFE101C
    #define FUNC_MUX_CTRL_7         *( unsigned int* )0xFFFE1020
    #define FUNC_MUX_CTRL_8         *( unsigned int* )0xFFFE1024
    #define FUNC_MUX_CTRL_9         *( unsigned int* )0xFFFE1028
    #define FUNC_MUX_CTRL_A         *( unsigned int* )0xFFFE102C
    #define FUNC_MUX_CTRL_B         *( unsigned int* )0xFFFE1030
    #define FUNC_MUX_CTRL_C         *( unsigned int* )0xFFFE1034
    #define FUNC_MUX_CTRL_D         *( unsigned int* )0xFFFE1038
    #define USB_TRANSCEIVER_CTRL    *( unsigned int* )0xFFFE1064
    #define FUNC_MUX_CTRL_E         *( unsigned int* )0xFFFE1090
    #define FUNC_MUX_CTRL_F         *( unsigned int* )0xFFFE1094
    #define FUNC_MUX_CTRL_10        *( unsigned int* )0xFFFE1098
    #define FUNC_MUX_CTRL_11        *( unsigned int* )0xFFFE109C
    #define FUNC_MUX_CTRL_12        *( unsigned int* )0xFFFE10A0
    #define PULL_DWN_CTRL_0         *( unsigned int* )0xFFFE1040
    #define PULL_DWN_CTRL_1         *( unsigned int* )0xFFFE1044
    #define PULL_DWN_CTRL_2         *( unsigned int* )0xFFFE1048
    #define PULL_DWN_CTRL_3         *( unsigned int* )0xFFFE104C
    #define PULL_DWN_CTRL_4         *( unsigned int* )0xFFFE10AC
    #define PU_PD_SEL_0             *( unsigned int* )0xFFFE10B4
    #define PU_PD_SEL_1             *( unsigned int* )0xFFFE10B8
    #define PU_PD_SEL_2             *( unsigned int* )0xFFFE10BC
    #define PU_PD_SEL_3             *( unsigned int* )0xFFFE10C0
    #define PU_PD_SEL_4             *( unsigned int* )0xFFFE10C4
    #define MOD_CONF_CTRL_0         *( unsigned int* )0xFFFE1080

    /* Disable Pin multiplexing */
    COMP_MODE_CTRL_0        = 0;

    /* Set pin multiplexing */
    FUNC_MUX_CTRL_0         = 0;
    FUNC_MUX_CTRL_1         = 0;
    FUNC_MUX_CTRL_2         = 0;
    FUNC_MUX_CTRL_3         = 0x09249FFF;
    FUNC_MUX_CTRL_4         = 0x3FE00001;
    FUNC_MUX_CTRL_5         = 0x3F4BFFFF;
    FUNC_MUX_CTRL_6         = 0x00000001;
    FUNC_MUX_CTRL_7         = 0x00001000;
    FUNC_MUX_CTRL_8         = 0x00001200;
    FUNC_MUX_CTRL_9         = 0x00201008;
    FUNC_MUX_CTRL_A         = 0;
    FUNC_MUX_CTRL_B         = 0;
    FUNC_MUX_CTRL_C         = 0x09000000;
    FUNC_MUX_CTRL_D         = 0x09249438;
    FUNC_MUX_CTRL_E         = 0x09249249;
    FUNC_MUX_CTRL_F         = 0x00000049;
    FUNC_MUX_CTRL_10        = 0;
    FUNC_MUX_CTRL_11        = 0;
    FUNC_MUX_CTRL_12        = 0;
    USB_TRANSCEIVER_CTRL    = 0;
    PULL_DWN_CTRL_0         = 0;
    PULL_DWN_CTRL_1         = 0;
    PULL_DWN_CTRL_2         = 0;
    PULL_DWN_CTRL_3         = 0;
    PULL_DWN_CTRL_4         = 0;
    PU_PD_SEL_0             = 0;
    PU_PD_SEL_1             = 0;
    PU_PD_SEL_2             = 0;
    PU_PD_SEL_3             = 0;
    PU_PD_SEL_4             = 0;
    MOD_CONF_CTRL_0         = 0;

    /* Enable Pin multiplexing */
    COMP_MODE_CTRL_0        = 0x0000EAEF;
}

/*--------------------------------------------------------------*/
/* setup_peripherals()                                          */
/* Peripheral Setup                                             */
/*--------------------------------------------------------------*/
setup_peripherals( )
{
    #define ARM_IDLECT1             *( unsigned int* )0xFFFECE04
    #define ARM_RSTCT2              *( unsigned int* )0xFFFECE14
    #define MPUI_CTRL_REG           *( unsigned int* )0xFFFEC900
    #define PRIB_TIPB_CNTL          *( unsigned short* )0xFFFECA00
    #define PUBB_TIPB_CNTL          *( unsigned short* )0xFFFED300

    ARM_RSTCT2      = 0x00000001;   // Enable ARM peripherals
    ARM_IDLECT1     = 0x00004000;   // Set clock signal on idle
    MPUI_CTRL_REG   = 0x0003FF2C;   // Set Access Width
    PRIB_TIPB_CNTL  = 0x0000FF22;   // ARM Private Bus
    PUBB_TIPB_CNTL  = 0x0000FF22;   // ARM Public Bus
}

/*--------------------------------------------------------------*/
/* disable_watchdog_timer()                                     */
/* Watchdog Timer Disable                                       */
/*--------------------------------------------------------------*/
disable_watchdog_timer( )
{
    #define WD_CNTL_TIMER           *( unsigned short* )0xFFFEC800
    #define WD_LOAD_TIM             *( unsigned short* )0xFFFEC804
    #define WD_TIMER_MODE           *( unsigned short* )0xFFFEC808
    #define WDT_WWPS                *( unsigned int* )0xFFFEB034
    #define WDT_WSPR                *( unsigned int* )0xFFFEB048

    WD_TIMER_MODE = 0x00F5;         // Disable Watchdog Timer
    WD_TIMER_MODE = 0x00A0;

    WDT_WSPR = 0xAAAA;              // Disable 32KHz Watchdog
    while ( WDT_WWPS & 0x0010 );
    WDT_WSPR = 0x5555;
    while ( WDT_WWPS & 0x0010 );
}

/*--------------------------------------------------------------*/
/* release_dsp_from_reset()                                     */
/* Releases DSP from reset & have it running in an idle loop    */
/*--------------------------------------------------------------*/
release_dsp_from_reset( )
{
    /* Register for DSP & ARM clocks + MPUI controls */
    #define ARM_CKCTL               *( unsigned int* )0xFFFECE00
    #define ARM_IDLECT2             *( unsigned int* )0xFFFECE08
    #define ARM_RSTCT1              *( unsigned int* )0xFFFECE10
    #define MPUI_CTRL_REG           *( unsigned int* )0xFFFEC900
    #define MPUI_DSP_BOOT_CONFIG    *( unsigned int* )0xFFFEC918
    #define MPUI_DSP_MPUI_CONFIG    *( unsigned int* )0xFFFEC91C
    #define DSP_CKCTL               *( unsigned short* )0xE1008000
    #define DSP_IDLECT1             *( unsigned short* )0xE1008004
    #define DSP_IDLECT2             *( unsigned short* )0xE1008008
    #define DSP_RSTCT2              *( unsigned short* )0xE1008014

    if ( ( ARM_RSTCT1 & 2 ) != 2 )
    {
        ARM_RSTCT1           = 0x00000004;  // Set priority regs to allow reprogramming
        MPUI_DSP_MPUI_CONFIG = 0x00000000;  // Set SARAM to be shared by DSP and ARM
        ARM_IDLECT2         |= 0x00000040;  // Enable clock for MPUI
        MPUI_CTRL_REG        = 0x0000FF2C;  // Turn off byte swap, set to MAX timeout

        /* Insert an idle loop at DSP [0x10000], mapped to ARM [0xE0010000]
         * The loop will continuously branch to itself  */
        *( unsigned short* )0xE0010000 = 0x2020;
        *( unsigned short* )0xE0010002 = 0x4A7E;
        *( unsigned short* )0xE0010004 = 0x2020;
        *( unsigned short* )0xE0010006 = 0x2020;

        /*  Set the DSP boot address to [0x010000], mapped to ARM [0xE0010000] */
        MPUI_DSP_BOOT_CONFIG = 0x00000005;

        DSP_IDLECT2 = 0x0027;       // Set Idle Register
        DSP_RSTCT2  = 0x0003;       // Enable Peripherals on DSP
        ARM_CKCTL  |= 0x00002000;   // Enable DSP clock
        DSP_IDLECT1 = 0x0177;       // Set Idle Register
        DSP_CKCTL   = 0x0090;       // Set DSP clock inputs
        ARM_RSTCT1 |= 0x00000002;   // Enable DSP
    }
}

/*--------------------------------------------------------------*/
/* reset_arm( )                                                 */
/* Resets the CPSR to ARM state, Supervisor mode                */
/* Disables MMU & CACHEs                                        */
/*--------------------------------------------------------------*/
reset_arm( )
{
    CPSR = 0x400000D3;          // Set CPSR to supervisor mode, disable IRQ/FIQ
  //PC = 0x00000000;            // Set PC to 0x00000000

    REG_CP15_FLSH_DI;           // Flush then disable D-Cache & I-Cache
    REG_CP15_I_CACHE = 0;
    REG_CP15_D_CACHE = 0;
    REG_CP15_MMU = 0;           // Disable MMU
}

/*--------------------------------------------------------------*/
/* reset_dsp( )                                                 */
/* Resets the DSP by disabling the DSP itself & the DSP reset   */
/* clock.                                                       */
/*--------------------------------------------------------------*/
reset_dsp( )
{
    #define ARM_CKCTL           *( unsigned int* )0xFFFECE00
    #define ARM_RSTCT1          *( unsigned int* )0xFFFECE10

    ARM_CKCTL  &= ~0x00002000;  // Turn off DSP clock
    ARM_RSTCT1 &= ~0x00000006;  // Reset DSP and disallow programming regs
}

/*--------------------------------------------------------------*/
/* OSK5912 MENU                                                 */
/*--------------------------------------------------------------*/
menuitem "OSK5912 Functions";

hotmenu Reset()
{
    GEL_Reset();
}
hotmenu ResetARM()
{
    reset_arm();
}
hotmenu ResetDSP()
{
    reset_dsp();
}
hotmenu ReleaseDSP()
{
    release_dsp_from_reset();
}
hotmenu InitEmif()
{
    init_emif();
}
hotmenu SetupPll_96MHz( )
{
    init_pll( 96 );
}
hotmenu SetupPll_192MHz()
{
    init_pll( 192 );
}

/*--------------------------------------------------------------*/
/* Memory Map Menu                                              */
/*--------------------------------------------------------------*/
menuitem "Memory Map";

hotmenu SetMemoryMap()
{
    setup_memory_map();
}
hotmenu ClearMemoryMap()
{
    clear_memory_map();
}

/*--------------------------------------------------------------*/
/* SetupMmu( )                                                  */
/* Sets MMU, I-CACHES                                           */
/*--------------------------------------------------------------*/
menuitem "MMU";

hotmenu setupMmu( )
{
    int table = 0x11FFC000;

    GEL_TextOut( "    Initializing MMU ( please wait )\n" );

    MMU_Section( table + 0x0000, 0x10000C0E, 32 );  // VA=0x000x:xxxx => PA=0x100x:xxxx
    MMU_Section( table + 0x0100, 0x04000C02, 32 );  // VA=0x040x:xxxx => PA=0x040x:xxxx
    MMU_Section( table + 0x0200, 0x08000C02, 32 );  // VA=0x080x:xxxx => PA=0x080x:xxxx
    MMU_Section( table + 0x0300, 0x0C000C02, 16 );  // VA=0x0C0x:xxxx => PA=0x0C0x:xxxx
    MMU_Section( table + 0x0400, 0x10000C0E, 32 );  // VA=0x100x:xxxx => PA=0x100x:xxxx
    MMU_Section( table + 0x0800, 0x20000C02, 16 );  // VA=0x200x:xxxx => PA=0x200x:xxxx
    MMU_Section( table + 0x1C00, 0x00000C02, 64 );  // VA=0x700x:xxxx => PA=0x000x:xxxx
    MMU_Section( table + 0x3800, 0xE0000C02, 32 );  // VA=0xE00x:xxxx => PA=0xE00x:xxxx
    MMU_Section( table + 0x3FFC, 0xFFF00C02,  1 );  // VA=0xFFFx:xxxx => PA=0xFFFx:xxxx

    REG_CP15_TT_BASE = table;
    REG_CP15_DACR    = 0xFFFFFFFF;
    REG_CP15_MMU     = 0x00001301;

    if ( REG_CP15_MMU )
    {
        /* CS4 - SDRAM remapped at 0x00000000 - 32MB */
        GEL_MapAddStr( 0x00000000, 0, 0x02000000, "R|W|AS4", 0 );

        /* CS0 - Flash remapped at 0x70000000 - 64MB */
        GEL_MapAddStr( 0x70000000, 0, 0x04000000, "R|W|AS4", 0 );

        GEL_TextOut( "    Initializing MMU ON ( complete )\n" );
    }
    else
        GEL_TextOut( "    Initializing MMU OFF ( complete )\n" );
}

MMU_Section( inAddr, inVal, inCount )
{
    int i;
    for ( i = 0; i < inCount; i++ )
        ( ( int * )inAddr )[i] = inVal + ( 0x100000 * i );
}
