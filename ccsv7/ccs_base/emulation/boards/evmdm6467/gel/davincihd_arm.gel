/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  davincihd_arm.gel                                                       *
 *  Version 0.99                                                            *
 *                                                                          *
 *  This GEL file is designed to be used in conjunction with                *
 *  CCStudio 3.2+ and the DM6467 based EVM.                                 *
 *                                                                          *
 * ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  StartUp( )                                                              *
 *      Setup Memory Map                                                    *
 *                                                                          *
 * ------------------------------------------------------------------------ */
StartUp( )
{
    Setup_Memory_Map( );
}

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  OnTargetConnect( )                                                      *
 *      Setup PinMux, Power, PLLs, DDR, & EMIF                              *
 *                                                                          *
 * ------------------------------------------------------------------------ */
OnTargetConnect( )
{
    GEL_TextOut( "\nDaVinci HD ARM Startup Sequence\n\n" );

    Disable_IRQ_Flush_Cache( );     // Clean up system state
    Enable_Instruction_Cache( );    // Enable I-Cache
    Setup_Pin_Mux( );               // Setup Pin Mux
    Setup_Psc_All_On( );            // Setup All Power Domains

    Setup_Pll0_594_MHz_OscIn( );    // Setup Pll0 [DSP @ 594 MHz, ARM @ 297 MHz]
    Setup_DDR_297_MHz( );           // Setup DDR2 [297 MHz]

    Setup_EMIFCS2_NandFlash_8Bit( );// Setup NAND Flash

    DSP_Boot_from_L2_ram( );        // Boot DSP from L2
    GEL_TextOut( "\nStartup Complete.\n\n" );
}

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  OnPreFileLoaded( )                                                      *
 *      This function is called automatically when the 'Load Program'       *
 *      Menu item is selected.                                              *
 *                                                                          *
 * ------------------------------------------------------------------------ */
OnPreFileLoaded( )
{
    /*
     *  GEL_Reset() is used to deal with the worst case senario of
     *  unknown target state.  If for some reason a reset is not desired
     *  upon target connection, GEL_Reset() may be removed and replaced
     *  with something "less brutal" like a cache initialization
     *  function.
     */
    GEL_Reset( );

    Disable_VPSS( );                // Disable VPSS
    Disable_IRQ_Flush_Cache( );     // Clean up system state
    Disable_EDMA( );                // Disable EDMA
  //Setup_DDR_297_MHz( );           // Setup DDR2 [297 MHz]

    GEL_TextOut( "\n" );
}

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  OnRestart( )                                                            *
 *      This function is called by CCS when you do Debug->Restart.          *
 *      The goal is to put the ARM9 into a known good state with respect to *
 *      edma.                                                               *
 *      Failure to do this can cause problems when you restart and          *
 *      run your application code multiple times.  This is different        *
 *      then OnPreFileLoaded() which will do a GEL_Reset() to get the       *
 *      ARM9 into a known good state.                                       *
 *                                                                          *
 * ------------------------------------------------------------------------ */
OnRestart( int nErrorCode )
{
    Disable_VPSS( );                // Disable VPSS
    Disable_IRQ_Flush_Cache( );     // Clean up system state
    Disable_EDMA( );                // Disable EDMA

    GEL_TextOut( "\n" );
}

menuitem "DaVinci HD Memory Map";

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  Setup_Memory_Map( )                                                     *
 *      Setup the Memory Map for ARM side only.                             *
 *                                                                          *
 * ------------------------------------------------------------------------ */
hotmenu
Setup_Memory_Map( )
{
    GEL_MapOn( );
    GEL_MapReset( );

    /* ARM RAM & ROM */
    GEL_MapAddStr( 0x00000000, 0, 0x00004000, "R|W|AS4", 0 );   // ARM RAM0 Instruction
    GEL_MapAddStr( 0x00004000, 0, 0x00004000, "R|W|AS4", 0 );   // ARM RAM1 Instruction
    GEL_MapAddStr( 0x00008000, 0, 0x00004000, "R|AS4",   0 );   // ARM ROM  Instruction
    GEL_MapAddStr( 0x00010000, 0, 0x00004000, "R|W|AS4", 0 );   // ARM RAM0 Data
    GEL_MapAddStr( 0x00014000, 0, 0x00004000, "R|W|AS4", 0 );   // ARM RAM1 Data
    GEL_MapAddStr( 0x00018000, 0, 0x00008000, "R|AS4",   0 );   // ARM ROM  Data

    /* Extend Trace */
    GEL_MapAddStr( 0x01bc0000, 0, 0x00001900, "R|W|AS4", 0 );   // ARM ETB

    /* Peripherals */
    GEL_MapAddStr( 0x01c00000, 0, 0x00000644, "R|W|AS4", 0 );   // EDMA Channel Ctrl
    GEL_MapAddStr( 0x01c01000, 0, 0x00000098, "R|W|AS4", 0 );   // EDMA Channel Ctrl
    GEL_MapAddStr( 0x01c02000, 0, 0x00000098, "R|W|AS4", 0 );   // EDMA Channel Ctrl
    GEL_MapAddStr( 0x01c02200, 0, 0x00000098, "R|W|AS4", 0 );   // EDMA Channel Ctrl
    GEL_MapAddStr( 0x01c10000, 0, 0x000003d8, "R|W|AS4", 0 );   // EDMA Transfer Ctrl 0
    GEL_MapAddStr( 0x01c10400, 0, 0x000003d8, "R|W|AS4", 0 );   // EDMA Transfer Ctrl 1
    GEL_MapAddStr( 0x01c10800, 0, 0x000003d8, "R|W|AS4", 0 );   // EDMA Transfer Ctrl 2
    GEL_MapAddStr( 0x01c10c00, 0, 0x000003d8, "R|W|AS4", 0 );   // EDMA Transfer Ctrl 3
    GEL_MapAddStr( 0x01c12000, 0, 0x00000400, "R|W|AS4", 0 );   // Video Port
    GEL_MapAddStr( 0x01c12800, 0, 0x00000800, "R|W|AS4", 0 );   // Graphics Engine
    GEL_MapAddStr( 0x01c13000, 0, 0x00000400, "R|W|AS4", 0 );   // Stream I/O 0
    GEL_MapAddStr( 0x01c13400, 0, 0x00000400, "R|W|AS4", 0 );   // Stream I/O 1
    GEL_MapAddStr( 0x01c1a000, 0, 0x00000800, "R|W|AS4", 0 );   // PCI Control
    GEL_MapAddStr( 0x01c20000, 0, 0x00000060, "R|W|AS4", 0 );   // UART 0
    GEL_MapAddStr( 0x01c20400, 0, 0x00000060, "R|W|AS4", 0 );   // UART 1
    GEL_MapAddStr( 0x01c20800, 0, 0x00000060, "R|W|AS4", 0 );   // UART 2
    GEL_MapAddStr( 0x01c21000, 0, 0x0000003c, "R|W|AS4", 0 );   // I2C
    GEL_MapAddStr( 0x01c21400, 0, 0x00000028, "R|W|AS4", 0 );   // Timer 0
    GEL_MapAddStr( 0x01c21800, 0, 0x00000028, "R|W|AS4", 0 );   // Timer 1
    GEL_MapAddStr( 0x01c21c00, 0, 0x0000002c, "R|W|AS4", 0 );   // Timer 2 WDT
    GEL_MapAddStr( 0x01c22000, 0, 0x0000001c, "R|W|AS4", 0 );   // PWM 0
    GEL_MapAddStr( 0x01c22400, 0, 0x0000001c, "R|W|AS4", 0 );   // PWM 1
    GEL_MapAddStr( 0x01c26000, 0, 0x00000058, "R|W|AS4", 0 );   // CRGEN0
    GEL_MapAddStr( 0x01c26400, 0, 0x00000058, "R|W|AS4", 0 );   // CRGEN1
    GEL_MapAddStr( 0x01c40000, 0, 0x00000080, "R|W|AS4", 0 );   // Device System
    GEL_MapAddStr( 0x01c40400, 0, 0x00000400, "R|W|AS4", 0 );   // Security Controller
    GEL_MapAddStr( 0x01c40800, 0, 0x00000178, "R|W|AS4", 0 );   // PLL0
    GEL_MapAddStr( 0x01c40c00, 0, 0x00000154, "R|W|AS4", 0 );   // PLL1
    GEL_MapAddStr( 0x01c41000, 0, 0x00000518, "R|W|AS4", 0 );   // PSC Domain Control
    GEL_MapAddStr( 0x01c41800, 0, 0x000000b8, "R|W|AS4", 0 );   // PSC Module Status
    GEL_MapAddStr( 0x01c41a00, 0, 0x000000b8, "R|W|AS4", 0 );   // PSC Module Control
    GEL_MapAddStr( 0x01c48000, 0, 0x00000050, "R|W|AS4", 0 );   // ARM Interrupts
    GEL_MapAddStr( 0x01c64000, 0, 0x00002000, "R|W|AS4", 0 );   // USB 2.0
    GEL_MapAddStr( 0x01c66000, 0, 0x0000007c, "R|W|AS2", 0 );   // ATA
    GEL_MapAddStr( 0x01c66800, 0, 0x00000068, "R|W|AS4", 0 );   // SPI
    GEL_MapAddStr( 0x01c67000, 0, 0x00000060, "R|W|AS4", 0 );   // GPIO
    GEL_MapAddStr( 0x01c67800, 0, 0x00000800, "R|W|AS4", 0 );   // HPI
    GEL_MapAddStr( 0x01c80000, 0, 0x0000028c, "R|W|AS4", 0 );   // EMAC Control
    GEL_MapAddStr( 0x01c81000, 0, 0x00000078, "R|W|AS4", 0 );   // EMAC Module
    GEL_MapAddStr( 0x01c82000, 0, 0x00002000, "R|W|AS4", 0 );   // EMAC Module RAM
    GEL_MapAddStr( 0x01c84000, 0, 0x00000090, "R|W|AS4", 0 );   // MDIO
    GEL_MapAddStr( 0x01d11000, 0, 0x00001400, "R|W|AS4", 0 );   // MCASP0
    GEL_MapAddStr( 0x01d11400, 0, 0x00000400, "R|W|AS4", 0 );   // MCASP0 Data
    GEL_MapAddStr( 0x01d11800, 0, 0x00000400, "R|W|AS4", 0 );   // MCASP1
    GEL_MapAddStr( 0x01d11c00, 0, 0x00000400, "R|W|AS4", 0 );   // MCASP1 Data
    GEL_MapAddStr( 0x02000000, 0, 0x00200000, "R|W|AS4", 0 );   // HD-VICP0
    GEL_MapAddStr( 0x02200000, 0, 0x00200000, "R|W|AS4", 0 );   // HD-VICP1

    /* HD-VICP0 */
    GEL_MapAddStr( 0x11400000, 0, 0x00100000, "R|W|AS4", 0 );   // HD-VICP0
    GEL_MapAddStr( 0x40400000, 0, 0x00040000, "R|W|AS4", 0 );   // HD-VICP0 R/W Port
    GEL_MapAddStr( 0x40440000, 0, 0x00040000, "R|W|AS4", 0 );   // HD-VICP0 R-Only Port
    GEL_MapAddStr( 0x40480000, 0, 0x00040000, "R|W|AS4", 0 );   // HD-VICP0 W-Only Port

    /* HD-VICP1 */
    GEL_MapAddStr( 0x11600000, 0, 0x00100000, "R|W|AS4", 0 );   // HD-VICP1
    GEL_MapAddStr( 0x40600000, 0, 0x00040000, "R|W|AS4", 0 );   // HD-VICP1 R/W Port
    GEL_MapAddStr( 0x40640000, 0, 0x00040000, "R|W|AS4", 0 );   // HD-VICP1 R-Only Port
    GEL_MapAddStr( 0x40680000, 0, 0x00040000, "R|W|AS4", 0 );   // HD-VICP1 W-Only Port

    /* DSP RAM */
    GEL_MapAddStr( 0x11818000, 0, 0x00020000, "R|W|AS4", 0 );   // DSP L2 RAM/Cache
    GEL_MapAddStr( 0x11e00000, 0, 0x00008000, "R|W|AS4", 0 );   // DSP L1P Cache/RAM
    GEL_MapAddStr( 0x11f00000, 0, 0x00008000, "R|W|AS4", 0 );   // DSP L1D Cache/RAM

    /* DDR2 */
    GEL_MapAddStr( 0x20000000, 0, 0x000000f4, "R|W|AS4", 0 );   // DDR2 Control
    GEL_MapAddStr( 0x80000000, 0, 0x40000000, "R|W|AS4", 0 );   // DDR2 SDRAM

    /* EMIFA */
    GEL_MapAddStr( 0x20008000, 0, 0x00000080, "R|W|AS4", 0 );   // EMIFA Control
    GEL_MapAddStr( 0x42000000, 0, 0x02000000, "R|W|AS4", 0 );   // AEMIF CS2
    GEL_MapAddStr( 0x44000000, 0, 0x02000000, "R|W|AS4", 0 );   // AEMIF CS3
    GEL_MapAddStr( 0x46000000, 0, 0x02000000, "R|W|AS4", 0 );   // AEMIF CS4
    GEL_MapAddStr( 0x48000000, 0, 0x02000000, "R|W|AS4", 0 );   // AEMIF CS5

    /* VLYNQ */
    GEL_MapAddStr( 0x20010000, 0, 0x00000048, "R|W|AS4", 0 );   // VLYNQ Control
  //GEL_MapAddStr( 0x20010080, 0, 0x00000068, "R|W|AS4", 0 );   // VLYNQ Control Remote
    GEL_MapAddStr( 0x4c000000, 0, 0x04000000, "R|W|AS4", 0 );   // VLYNQ Remote Devices

    /* PCI */
    GEL_MapAddStr( 0x30000000, 0, 0x10000000, "R|W|AS4", 0 );   // PCI Address Space
}

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  Clear_Memory_Map( )                                                     *
 *      Clear the Memory Map                                                *
 *                                                                          *
 * ------------------------------------------------------------------------ */
hotmenu
Clear_Memory_Map( )
{
    GEL_MapOff( );
    GEL_MapReset( );
}

menuitem "DaVinci HD Functions";

_wait( int delay )
{
    int i;
    for( i = 0 ; i < delay ; i++ ){}
}

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  Flush_Cache_Disable_MMU( )                                              *
 *      Flush Cache & Disable MMU                                           *
 *                                                                          *
 * ------------------------------------------------------------------------ */
Disable_IRQ_Flush_Cache( )
{
    #define INTC_FIQ0               *( unsigned int* )( 0x01c48000 )
    #define INTC_FIQ1               *( unsigned int* )( 0x01c48004 )
    #define INTC_IRQ0               *( unsigned int* )( 0x01c48008 )
    #define INTC_IRQ1               *( unsigned int* )( 0x01c4800c )
    #define INTC_EINT0              *( unsigned int* )( 0x01c48018 )
    #define INTC_EINT1              *( unsigned int* )( 0x01c4801c )
    #define INTC_INTCTL             *( unsigned int* )( 0x01c48020 )
    #define INTC_EABASE             *( unsigned int* )( 0x01c48024 )

    GEL_TextOut( "Disable IRQ/FIQ\n" );

    CPSR = 0x400000d3;              // Set to supervisor mode, disable IRQ/FIQ

    GEL_TextOut( "Flush Cache\n" );
    REG_CP15_FLSH_DI;               // Flush then disable D-Cache & I-Cache
    REG_CP15_I_CACHE = 0;
    REG_CP15_D_CACHE = 0;

    GEL_TextOut( "Disable MMU\n" );
    REG_CP15_MMU = 0;               // Disable MMU

    INTC_INTCTL = 4;                // Disable ARM interrupts
    INTC_EABASE = 0;
    INTC_EINT0  = 0;
    INTC_EINT1  = 0;

    INTC_FIQ0 = 0xffffffff;
    INTC_FIQ1 = 0xffffffff;
    INTC_IRQ0 = 0xffffffff;
    INTC_IRQ1 = 0xffffffff;

    _wait( 200 );
}

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  Disable_VPSS( )                                                         *
 *      Disable VPFE & VPBE                                                 *
 *                                                                          *
 * ------------------------------------------------------------------------ */
Disable_VPSS( )
{
    #define VPIF_CHCTRL0            *( unsigned int* )( 0x01c12004 )
    #define VPIF_CHCTRL1            *( unsigned int* )( 0x01c12008 )
    #define VPIF_CHCTRL2            *( unsigned int* )( 0x01c1200c )
    #define VPIF_CHCTRL3            *( unsigned int* )( 0x01c12010 )
    #define VPIF_INTEN              *( unsigned int* )( 0x01c12020 )
    #define VPIF_INTENCLR           *( unsigned int* )( 0x01c12028 )

    GEL_TextOut( "Disable VPSS\n" );
    VPIF_CHCTRL0 = 0;
    VPIF_CHCTRL1 = 0;
    VPIF_CHCTRL2 = 0;
    VPIF_CHCTRL3 = 0;

    VPIF_INTEN    = 0;
    VPIF_INTENCLR = 0x0f;

    /* Clear Channels */
  //GEL_MemoryFill( 0x01c12040, 0, 104, 0 ); // Channel 0-3
}

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  Disable_EDMA( )                                                         *
 *      Disabe EDMA events and interrupts, clear any pending events         *
 *                                                                          *
 * ------------------------------------------------------------------------ */
Disable_EDMA( )
{
    #define EDMA_3CC_IECRH          *( unsigned int* )( 0x01c0105c )
    #define EDMA_3CC_EECRH          *( unsigned int* )( 0x01c0102c )
    #define EDMA_3CC_ICRH           *( unsigned int* )( 0x01c01074 )
    #define EDMA_3CC_ECRH           *( unsigned int* )( 0x01c0100c )

    #define EDMA_3CC_IECR           *( unsigned int* )( 0x01c01058 )
    #define EDMA_3CC_EECR           *( unsigned int* )( 0x01c01028 )
    #define EDMA_3CC_ICR            *( unsigned int* )( 0x01c01070 )
    #define EDMA_3CC_ECR            *( unsigned int* )( 0x01c01008 )

    GEL_TextOut( "Disable EDMA events\n" );

    EDMA_3CC_IECRH  = 0xffffffff;   // IERH - Disable high interrupts
    EDMA_3CC_EECRH  = 0xffffffff;   // EERH - Disable high events
    EDMA_3CC_ICRH   = 0xffffffff;   // ICRH - Clear high interrupts
    EDMA_3CC_ECRH   = 0xffffffff;   // ICRH - Clear high events

    EDMA_3CC_IECR   = 0xffffffff;   // IER  - Disable low interrupts
    EDMA_3CC_EECR   = 0xffffffff;   // EER  - Disable low events
    EDMA_3CC_ICR    = 0xffffffff;   // ICR  - Clear low interrupts
    EDMA_3CC_ECR    = 0xffffffff;   // ICRH - Clear low events
}

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  Enable_Instruction_Cache( )                                             *
 *      Enable I-Cache                                                      *
 *                                                                          *
 * ------------------------------------------------------------------------ */
hotmenu Enable_Instruction_Cache( )
{
    GEL_TextOut( "\Enable Instruction Cache.\n\n" );

    CPSR = 0x400000d3;              // Set to supervisor mode, disable IRQ/FIQ
    REG_CP15_I_CACHE = 1;           // Enable Instruction Cache
} 

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  Setup_Pin_Mux( )                                                        *
 *      Configure Pin Multiplexing                                          *
 *                                                                          *
 * ------------------------------------------------------------------------ */
hotmenu
Setup_Pin_Mux( )
{
    int pcien;
    #define PINMUX0                 *( unsigned int* )( 0x01c40000 )
    #define PINMUX1                 *( unsigned int* )( 0x01c40004 )
    #define VDD3P3V_PWDN            *( unsigned int* )( 0x01c40048 )

    GEL_TextOut( "Setup PinMux... " );
    pcien = ( PINMUX0 & ( 1 << 2 ) );

    /*
     *  PinMux settings for:
     *      [Normal Operation]
     */
    if ( pcien == 0 )
    {
        PINMUX0 = 0x00000001;
        /*  | ( 0 << 31 )           // VBUSDIS      [USB_DRVVBUS]
            | ( 0 << 30 )           // STCCK        [GPIO4]
            | ( 0 << 29 )           // AUDCK1       [GPIO2]
            | ( 0 << 28 )           // AUDCK0       [GPIO3]
            | ( 0 << 24 )           // [2]CRGMUX    [no CRGEN]
            | ( 0 << 22 )           // [2]TSSOMUX   [VP_DOUT[11:8]]
            | ( 0 << 20 )           // [2]TSSIMUX   [VP_DIN[7:0]]
            | ( 0 << 18 )           // [2]PTSOMUX   [VP_DIN[7:0]]
            | ( 0 << 16 )           // [2]PTSIMUX   [VP_DIN[15:8]]
            | ( 0 << 5 )            // PINTD        [GPIO5]
            | ( 0 << 2 )            // PCIEN        [no PCI]
            | ( 0 << 1 )            // HPIEN        [no HPI]
            | ( 1 << 0 );           // ATAEN        [ATA/NAND]*/

        PINMUX1 = 0x0000002d;
        /*  | ( 2 << 4 )            // [2]UART2CTL  [IrDA]
            | ( 3 << 2 )            // [2]UART1CTL  [GPIO]
            | ( 1 << 0 );           // [2]UART0CTL  [UART0 w/o Flow]*/
    }

    /*
     *  PinMux settings for:
     *      [PCI Operation]
     */
    else
    {
        PINMUX0 = 0x00000024;
        /*  | ( 0 << 31 )           // VBUSDIS      [USB_DRVVBUS]
            | ( 0 << 30 )           // STCCK        [GPIO4]
            | ( 0 << 29 )           // AUDCK1       [GPIO2]
            | ( 0 << 28 )           // AUDCK0       [GPIO3]
            | ( 0 << 24 )           // [2]CRGMUX    [no CRGEN]
            | ( 0 << 22 )           // [2]TSSOMUX   [VP_DOUT[11:8]]
            | ( 0 << 20 )           // [2]TSSIMUX   [VP_DIN[7:0]]
            | ( 0 << 18 )           // [2]PTSOMUX   [VP_DIN[7:0]]
            | ( 0 << 16 )           // [2]PTSIMUX   [VP_DIN[15:8]]
            | ( 1 << 5 )            // PINTD        [PINTD]
            | ( 1 << 2 )            // PCIEN        [PCI]
            | ( 0 << 1 )            // HPIEN        [no HPI]
            | ( 0 << 0 );           // ATAEN        [no ATA]*/

        PINMUX1 = 0x0000002d;
        /*  | ( 2 << 4 )            // [2]UART2CTL  [IrDA]
            | ( 3 << 2 )            // [2]UART1CTL  [GPIO]
            | ( 1 << 0 );           // [2]UART0CTL  [UART0 w/o Flow]*/
    }

    /* 3.3V Power Domain */
    VDD3P3V_PWDN = 0x180000c0;
    /*  | ( 1 << 28 )               // USBV     [Power Down][-> USB +5V]
        | ( 1 << 27 )               // CLKOUT   [Power Down][-> DC_P2]
        | ( 0 << 25 )               // SPI      [Power Up]
        | ( 0 << 24 )               // VLYNQ    [Power Up]
        | ( 0 << 21 )               // GMII     [Power Up]
        | ( 0 << 20 )               // MII      [Power Up]
        | ( 0 << 19 )               // McASP1   [Power Up]
        | ( 0 << 18 )               // McASP0   [Power Up]
        | ( 0 << 17 )               // PCIHPI1  [Power Up]
        | ( 0 << 16 )               // PCIHPI0  [Power Up]
        | ( 0 << 15 )               // GPIO     [Power Up]
        | ( 0 << 14 )               // WDTIM    [Power Up]
        | ( 0 << 13 )               // TIM23    [Power Up]
        | ( 0 << 12 )               // TIM01    [Power Up]
        | ( 0 << 11 )               // PWM1     [Power Up]
        | ( 0 << 10 )               // PWM0     [Power Up]
        | ( 0 << 9 )                // UR2FC    [Power Up]
        | ( 0 << 8 )                // UR2DAT   [Power Up]
        | ( 1 << 7 )                // UR1FC    [Power Down]
        | ( 1 << 6 )                // UR1DAT   [Power Down]
        | ( 0 << 5 )                // UR0MDM   [Power Up]
        | ( 0 << 4 )                // UR0DF    [Power Up]
        | ( 0 << 3 )                // VPIF3    [Power Up]
        | ( 0 << 2 )                // VPIF2    [Power Up]
        | ( 0 << 1 )                // VPIF1    [Power Up]
        | ( 0 << 0 );               // VPIF0    [Power Up]*/

    GEL_TextOut( "[Done]\n" );
}

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  Setup_Psc_All_On( )                                                     *
 *      Enable all PSC modules on ALWAYSON and DSP power dominas.           *
 *                                                                          *
 * ------------------------------------------------------------------------ */
hotmenu
Setup_Psc_All_On( )
{
    int i;
    GEL_TextOut( "Setup Power Modules (All on)... " );

    /*
     *  Enable all non-reserved power modules
     *  Reserved: 36-44
     */
    for ( i = 1 ; i <= 35 ; i++ )
        psc_change_state( i , 3 );
    i = 45;
        psc_change_state( i , 3 );

    GEL_TextOut( "[Done]\n" );
}

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  psc_change_state( id, state )                                           *
 *      id    = Domain #ID                                                  *
 *      state = ( ENABLE, DISABLE, SYNCRESET, RESET )                       *
 *              (   =3  ,   =2   ,    =1    ,   =0  )                       *
 *                                                                          *
 * ------------------------------------------------------------------------ */
psc_change_state( int id, int state )
{
    #define PSC_PTCMD               *( unsigned int* )( 0x01c41120 )
    #define PSC_PTSTAT              *( unsigned int* )( 0x01c41128 )
    unsigned int* mdstat            = ( unsigned int* )( 0x01c41800 + ( 4 * id ) );
    unsigned int* mdctl             = ( unsigned int* )( 0x01c41a00 + ( 4 * id ) );

    /*
     *  Step 0 - Ignore request if the state is already set as is
     */
    if ( ( *mdstat & 0x001f ) == state )
        return;

    /*
     *  Step 1 - Wait for PTSTAT.GOSTAT to clear
     */
    while( PSC_PTSTAT & 1 );

    /*
     *  Step 2 - Set MDCTLx.NEXT to new state
     */
    *mdctl &= ~0x1f;
    *mdctl |= state;

    /*
     *  Step 3 - Start power transition ( set PTCMD.GO to 1 )
     */
    PSC_PTCMD = 1;

    /*
     *  Step 4 - Wait for PTSTAT.GOSTAT to clear
     */
    while( PSC_PTSTAT & 1 );

    /*
     *  Step 5 - Verify state changed
     */
    while( ( *mdstat & 0x001f ) != state );
}

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  setup_pll_0( )                                                          *
 *                                                                          *
 *      clock_source    <- 0: Onchip Oscillator                             *
 *                         1: External Clock                                *
 *                                                                          *
 *      pll_mult        <- 21: 22x Multiplier * 27MHz Clk = 594 MHz         *
 *                                                                          *
 * ------------------------------------------------------------------------ */
setup_pll_0( int clock_source, int pll_mult )
{
    unsigned int* pll_ctl       = ( unsigned int* )( 0x01c40900 );
    unsigned int* pll_pllm      = ( unsigned int* )( 0x01c40910 );
    unsigned int* pll_cmd       = ( unsigned int* )( 0x01c40938 );
    unsigned int* pll_postdiv   = ( unsigned int* )( 0x01c40928 );
    unsigned int* pll_bpdiv     = ( unsigned int* )( 0x01c4092c );
    unsigned int* pll_div1      = ( unsigned int* )( 0x01c40918 );
    unsigned int* pll_div2      = ( unsigned int* )( 0x01c4091c );
    unsigned int* pll_div3      = ( unsigned int* )( 0x01c40920 );
    unsigned int* pll_div4      = ( unsigned int* )( 0x01c40960 );
    unsigned int* pll_div5      = ( unsigned int* )( 0x01c40964 );
    unsigned int* pll_div6      = ( unsigned int* )( 0x01c40968 );
    unsigned int* pll_div7      = ( unsigned int* )( 0x01c4096c );
    unsigned int* pll_div8      = ( unsigned int* )( 0x01c40970 );
    unsigned int* pll_div9      = ( unsigned int* )( 0x01c40974 );

    int pll0_freq = 27 * ( pll_mult + 1 );
    int dsp_freq = pll0_freq;
    int arm_freq = pll0_freq / 2;
    int postdiv = 0;
    int bpdiv = 0;

    GEL_TextOut( "Setup PLL0 " );

    /*
     *  Step 1 - Set clock mode
     */
    if ( clock_source == 0 )
        *pll_ctl &= ~0x0100;        // Onchip Oscillator
    else
        *pll_ctl |= 0x0100;         // External Clock

    /*
     *  Step 2 - Set PLL to bypass
     *         - Wait for PLL to stabilize
     */
    *pll_ctl &= ~0x0020;
    *pll_ctl &= ~0x0001;
    _wait( 150 );

    /*
     *  Step 3 - Reset PLL
     */
    *pll_ctl |= 0x0008;

    /*
     *  Step 4 - Disable PLL
     *  Step 5 - Powerup PLL
     *  Step 6 - Enable PLL
     *  Step 7 - Wait for PLL to stabilize
     */
    *pll_ctl |= 0x0010;             // Disable PLL
    *pll_ctl &= ~0x0002;            // Power up PLL
    *pll_ctl &= ~0x0010;            // Enable PLL
    _wait( 150 );                   // Wait for PLL to stabilize

    /*
     *  Step 8 - Load PLL multiplier
     */
    *pll_pllm = pll_mult & 0x3f;

    /*
     *  Step 9 - Set PLL post dividers
     *           Div1: (Fixed @ /1)DSP
     *           Div2: (Fixed @ /2)ARM/PCI/GraphicsEngine/HD-VICP0-1/EDMA/SCR
     *           Div3: (Fixed @ /4)Peripherals
     *           Div4: ATA
     *           Div5: SYSCLK5
     *           Div6: SYSCLK6
     *           Div7: SYSCLK7
     *           Div8: VIDEO
     *           Div9: VLYNQ
     */
    *pll_div1   = 0x8000 | 0;       // DSP
    *pll_div2   = 0x8000 | 1;       // ARM/PCI/HDVICP
    *pll_div3   = 0x8000 | 3;       // Peripherals
    *pll_div4   = 0x8000 | 5;       // ATA divider
  //*pll_div5   = 0x8000 | 7;
  //*pll_div6   = 0x8000 | 7;
  //*pll_div7   = 0x8000 | 7;
    *pll_div8   = 0x8000 | 7;       // Video Clock
    *pll_div9   = 0x8000 | 5;       // VLYNQ divider
  //*pll_bpdiv  = 0x8000 | bpdiv;   // Bypass divider
  //*pll_postdiv= 0x8000 | postdiv; // Post divider 
    *pll_cmd   |= 0x0001;           // GO
    _wait( 2000 );

    /*
     *  Step 10 - Wait for PLL to reset ( 2000 cycles )
     *  Step 11 - Release from reset
     */
    _wait( 2000 );
    *pll_ctl &= ~0x0008;

    /*
     *  Step 12 - Wait for PLL to re-lock ( 2000 cycles )
     *  Step 13 - Switch out of BYPASS mode
     */
    _wait( 2000 );
    *pll_ctl |= 0x0001;

    pll0_freq = 27 * ( ( *pll_pllm & 0x3f ) + 1 );
    dsp_freq = pll0_freq;
    arm_freq = pll0_freq / 2;

    GEL_TextOut( "(DSP = %d MHz + ",,,,, dsp_freq );
    GEL_TextOut( "ARM = %d MHz + ",,,,, arm_freq );

    if ( clock_source == 0 )
        GEL_TextOut( "Onchip Oscillator)... " );
    else
        GEL_TextOut( "External Clock)... " );

    GEL_TextOut( "[Done]\n" );
}

hotmenu
Setup_Pll0_594_MHz_OscIn( )
{
    /* DSP @ [594 MHz] & ARM @ [297 MHz] w/ Onchip Oscillator */
    setup_pll_0( 0, 21 );
}

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  setup_pll_1( )                                                          *
 *                                                                          *
 *      clock_source    <- 0: Onchip Oscillator                             *
 *                         1: External Clock                                *
 *                                                                          *
 *      pll_mult        <- PLL Multiplier                                   *
 *                         23: 24x Multiplier * 27MHz Clk = 648 MHz         *
 *                                                                          *
 *      ddr2_div        <- DDR2 divider ( For pll1 )                        *
 *                         1: 648 MHz Clk / (2*2)x Divider = 162 MHz        *
 *                                                                          *
 * ------------------------------------------------------------------------ */
setup_pll_1( int clock_source, int pll_mult, int ddr2_div )
{
    unsigned int* pll_ctl       = ( unsigned int* )( 0x01c40d00 );
    unsigned int* pll_pllm      = ( unsigned int* )( 0x01c40d10 );
    unsigned int* pll_cmd       = ( unsigned int* )( 0x01c40d38 );
    unsigned int* pll_stat      = ( unsigned int* )( 0x01c40d3c );
    unsigned int* pll_div1      = ( unsigned int* )( 0x01c40d18 );
    unsigned int* pll_div2      = ( unsigned int* )( 0x01c40d1c );
    unsigned int* pll_bpdiv     = ( unsigned int* )( 0x01c40d2c );

    int pll1_freq = 27 * ( pll_mult + 1 );
    int ddr2_freq = pll1_freq / ( 2 * ( ddr2_div + 1 ) );
    int bpdiv = 1;

    GEL_TextOut( "Setup PLL1 " );

    /*
     *  Step 0 - Stop all peripheral operations
     */

    /*
     *  Step 1 - Set clock mode
     */
    if ( clock_source == 0 )
        *pll_ctl &= ~0x0100;        // Onchip Oscillator
    else
        *pll_ctl |= 0x0100;         // External Clock

    /*
     *  Step 2 - Set PLL to bypass
     *         - Wait for PLL to stabilize
     */
    *pll_ctl &= ~0x0020;
    *pll_ctl &= ~0x0001;
    _wait( 150 );

    /*
     *  Step 3 - Reset PLL
     */
    *pll_ctl |= 0x0008;

    /*
     *  Step 4 - Disable PLL
     *  Step 5 - Powerup PLL
     *  Step 6 - Enable PLL
     *  Step 7 - Wait for PLL to stabilize
     */
    *pll_ctl |= 0x0010;             // Disable PLL
    *pll_ctl &= ~0x0002;            // Power up PLL
    *pll_ctl &= ~0x0010;            // Enable PLL
    _wait( 150 );                   // Wait for PLL to stabilize

    /*
     *  Step 8 - Load PLL multiplier
     */
    *pll_pllm = pll_mult & 0x3f;

    /*
     *  Step 9 - Load PLL dividers ( must be in a 1/3/6 ratio )
     *           1:DDR2
     */
    *pll_bpdiv = 0x8000 | bpdiv;
    *pll_div2  = 0x8000 | ( ddr2_div & 0x1f );
    *pll_cmd  |= 0x0001;            // Set phase alignment
    while( ( *pll_stat & 1 ) != 0 );// Wait for phase alignment

    /*
     *  Step 10 - Wait for PLL to reset ( 2000 cycles )
     *  Step 11 - Release from reset
     */
    _wait( 2000 );
    *pll_ctl &= ~0x0008;

    /*
     *  Step 12 - Wait for PLL to re-lock ( 2000 cycles )
     *  Step 13 - Switch out of BYPASS mode
     */
    _wait( 2000 );
    *pll_ctl |= 0x0001;

    pll1_freq = 27 * ( ( *pll_pllm & 0x3f ) + 1 );
    ddr2_freq = pll1_freq / ( 2 * ( ( *pll_div2 & 0x1f ) + 1 ) );

    GEL_TextOut( "(DDR2 Phy = %d MHz + ",,,,, ddr2_freq );

    if ( clock_source == 0 )
        GEL_TextOut( "Onchip Oscillator)... " );
    else
        GEL_TextOut( "External Clock)... " );

    GEL_TextOut( "[Done]\n" );
}

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  setup_ddr2( )                                                           *
 *      Configure DDR2 to run at specified frequency.                       *
 *                                                                          *
 * ------------------------------------------------------------------------ */
setup_ddr2( int freq )
{
    #define DDR_SDBCR               *( unsigned int* )( 0x20000008 )
    #define DDR_SDRCR               *( unsigned int* )( 0x2000000c )
    #define DDR_SDTIMR              *( unsigned int* )( 0x20000010 )
    #define DDR_SDTIMR2             *( unsigned int* )( 0x20000014 )
    #define DDR_DDRPHYCR            *( unsigned int* )( 0x200000e4 )

    int dummy_read;
    int pch_nch;
    int refresh_rate;

    GEL_TextOut( "Setup DDR2 (%d MHz + 32-bit bus)... ",,,,, freq );

    /*
     *  Step 1 - Setup pll1
     *  Step 2 - Enable DDR2 PHY
     */
    psc_change_state( 20, 3 );

    /*
     *  Step 3 - DDR2 Initialization
     */
    DDR_DDRPHYCR = 0x00008AC7;      // DLL powered, ReadLatency=7
    DDR_SDBCR    = 0x08D78A32;      // DDR Bank: 32-bit bus, CAS=5,
                                    // 8 banks, 1024-word pg, unlocl
    DDR_SDTIMR   = 0x4B245C12;
    DDR_SDTIMR2  = 0x3B2BC742;
    DDR_SDRCR    = 0x90D;           // Refresh Control [ 7.8 us * 297 MHz ]

    DDR_SDBCR    = 0x08570A32;      // Lock values


    /*
     *  Step 4 - Dummy Read from DDR2
     */
    dummy_read = *( int* )0x80000000;

    /*
     *  Step 5 - Soft Reset ( SYNCRESET followed by ENABLE ) of DDR2 PHY
     */
    psc_change_state( 20, 1 );
    psc_change_state( 20, 3 );

    GEL_TextOut( "[Done]\n" );
}

hotmenu
Setup_DDR_297_MHz( )
{
    /* [DDR @ 297 MHz] w/ Onchip Oscillator */
    setup_pll_1( 0, 21, 0 );
    setup_ddr2( 297 );
}

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  setup_aemif( )                                                          *
 *      Setup Async-EMIF to Max Wait cycles and specified bus width.        *
 *                                                                          *
 * ------------------------------------------------------------------------ */
#define EMIF_CS2                    2
#define EMIF_CS3                    3
#define EMIF_CS4                    4
#define EMIF_CS5                    5

#define NO_NAND_FLASH               0
#define YES_NAND_FLASH              1

setup_aemif( int chip_select, int chip_config, int using_nand_flash )
{
    int nand_flash_bit;
    #define AEMIF_A1CR              *( unsigned int* )( 0x20008010 )
    #define AEMIF_A2CR              *( unsigned int* )( 0x20008014 )
    #define AEMIF_A3CR              *( unsigned int* )( 0x20008018 )
    #define AEMIF_A4CR              *( unsigned int* )( 0x2000801c )
    #define AEMIF_NANDFCR           *( unsigned int* )( 0x20008060 )

    /* Setup AEMIF memory space */
    if ( chip_select == EMIF_CS2 )
        AEMIF_A1CR = chip_config;
    else if ( chip_select == EMIF_CS3 )
        AEMIF_A2CR = chip_config;
    else if ( chip_select == EMIF_CS4 )
        AEMIF_A3CR = chip_config;
    else if ( chip_select == EMIF_CS5 )
        AEMIF_A4CR = chip_config;
    else
        return;

    nand_flash_bit = 1 << ( chip_select - 2 );

    /* Enable or Disable Hw NAND controller */
    if ( using_nand_flash == NO_NAND_FLASH )
        AEMIF_NANDFCR &= ~nand_flash_bit;
    else
        AEMIF_NANDFCR |= nand_flash_bit;
}

/*hotmenu*/
Reset_EMIF_8Bit_Bus( )
{
    int max_timeout = 0x3ffffffc;
    setup_aemif( EMIF_CS2, max_timeout, NO_NAND_FLASH );
    setup_aemif( EMIF_CS3, max_timeout, NO_NAND_FLASH );
    setup_aemif( EMIF_CS4, max_timeout, NO_NAND_FLASH );
    setup_aemif( EMIF_CS5, max_timeout, NO_NAND_FLASH );
}

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  Setup_EMIFCS2_NandFlash_8Bit( )                                        *
 *      Setup Async-EMIF for NAND Flash                                     *
 *                                                                          *
 * ------------------------------------------------------------------------ */
hotmenu
Setup_EMIFCS2_NandFlash_8Bit( )
{
    #define NAND_CMD    *( unsigned char* )( 0x42080000 )
    #define CMD_RESET   0xff

    GEL_TextOut( "Setup EMIF CS2 - NAND Flash (8-bit bus)... " );

    /* NAND Flash settings ( @ 99MHz or below ) */
    setup_aemif( EMIF_CS2, 0x028442a8, NO_NAND_FLASH );

    /* Reset Flash memory to Read Mode */
    NAND_CMD = CMD_RESET;

    GEL_TextOut( "[Done]\n" );
}

menuitem "DaVinci HD Boot Mode";

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  Boot_Mode_Reader( )                                                     *
 *      Read and Print boot mode                                            *
 *                                                                          *
 * ------------------------------------------------------------------------ */
hotmenu
Boot_Mode_Reader( )
{
    #define SYS_BOOTCFG     *( unsigned int* )( 0x01c40014 )
    int dsp_boot            = ( SYS_BOOTCFG >> 17 ) & 1;
    int pci_enable          = ( SYS_BOOTCFG >> 16 ) & 1;
    int voltage_adjust      = ( SYS_BOOTCFG >> 12 ) & 1;
    int emifa_bus_width     = ( SYS_BOOTCFG >> 8 )  & 1;
    int boot_mode           = ( SYS_BOOTCFG >> 0  ) & 0x0f;

    GEL_TextOut( "\nBoot Mode Reader:\n" );

    if ( boot_mode == 0 )
        GEL_TextOut( "  > [Boot Mode]   : EMU Boot\n" );
    else if ( ( boot_mode == 2 ) && ( pci_enable == 0 ) )
        GEL_TextOut( "  > [Boot Mode]   : HPI-16 Boot\n" );
    else if ( ( boot_mode == 2 ) && ( pci_enable == 1 ) )
        GEL_TextOut( "  > [Boot Mode]   : PCI Boot w/o auto init\n" );
    else if ( ( boot_mode == 3 ) && ( pci_enable == 0 ) )
        GEL_TextOut( "  > [Boot Mode]   : HPI-32 Boot\n" );
    else if ( ( boot_mode == 3 ) && ( pci_enable == 1 ) )
        GEL_TextOut( "  > [Boot Mode]   : PCI Boot w/ auto init\n" );
    else if ( boot_mode == 4 )
        GEL_TextOut( "  > [Boot Mode]   : EMIFA Direct Boot\n" );
    else if ( boot_mode == 6 )
        GEL_TextOut( "  > [Boot Mode]   : I2C Boot\n" );
    else if ( ( boot_mode == 7 ) && ( pci_enable == 0 ) )
        GEL_TextOut( "  > [Boot Mode]   : NAND Boot\n" );
    else if ( boot_mode == 8 )
        GEL_TextOut( "  > [Boot Mode]   : UART0 Boot\n" );
    else if ( boot_mode == 9 )
        GEL_TextOut( "  > [Boot Mode]   : Emulation Boot\n" );
    else if ( boot_mode == 10 )
        GEL_TextOut( "  > [Boot Mode]   : VLYNQ Boot\n" );
    else if ( boot_mode == 11 )
        GEL_TextOut( "  > [Boot Mode]   : EMAC Boot\n" );
    else if ( boot_mode == 14 )
        GEL_TextOut( "  > [Boot Mode]   : SPI Boot\n" );
    else
        GEL_TextOut( "  >>>>>> ERROR boot option not supported <<<<<<\n" );

    if ( dsp_boot == 0 )
        GEL_TextOut( "  > [DSP BOOT]    : ARM boots DSP\n" );
    if ( dsp_boot == 1 )
        GEL_TextOut( "  > [DSP BOOT]    : DSP self-boots\n" );

    if ( pci_enable == 0 )
        GEL_TextOut( "  > [PCI]         : OFF\n" );
    if ( pci_enable == 1 )
        GEL_TextOut( "  > [PCI]         : ON\n" );

    if ( voltage_adjust == 0 )
        GEL_TextOut( "  > [Voltage Adj] : SmartReflex Disable\n" );
    if ( voltage_adjust == 1 )
        GEL_TextOut( "  > [Voltage Adj] : SmartReflex Enable\n" );

    if ( emifa_bus_width == 0 )
        GEL_TextOut( "  > [Bus Width]   : 8-bit\n" );
    if ( emifa_bus_width == 1 )
        GEL_TextOut( "  > [Bus Width]   : 16-bit\n" );

    GEL_TextOut( "\n" );
}

menuitem "DaVinci HD DSP";

/* ------------------------------------------------------------------------ *
 *                                                                          *
 *  boot_dsp_from_arm( )                                                    *
 *      Boot DSP from ARM side.                                             *
 *                                                                          *
 * ------------------------------------------------------------------------ */
boot_dsp_from_arm( unsigned int boot_address )
{
    #define DSPBOOTADDR             *( unsigned int* )( 0x01c40008 )
    #define PSC_MDCTL_DSP           *( unsigned int* )( 0x01c41a00 + ( 4 * 1 ) )

    GEL_TextOut( "Boot DSP from %x ... ",,,,, boot_address );

    /*
     *  Step 1 - Turn DSP power ON
     */
    psc_change_state( 1, 3 );

    /*
     *  Step 2 - Assert local reset
     */
    PSC_MDCTL_DSP &= 0xfeff;

    /*
     *  Step 3 - Program DSP boot address
     *         - Fill in memory w/ branch to self opcode
     */
    DSPBOOTADDR = boot_address;
  //GEL_MemoryFill( boot_address, 0, 32, 0x13 );
    GEL_MemoryFill( boot_address, 0, 32, 0x0000a120 );

    /*
     *  Step 4 - Release from reset
     */
    PSC_MDCTL_DSP |= 0x0100;
    GEL_TextOut( "[Done]\n" );
}

hotmenu
DSP_Boot_from_L2_ram( )
{
    /* L2 RAM Memory */
    boot_dsp_from_arm( 0x11800000 );
}

hotmenu
DSP_Boot_from_DDR2( )
{
    /* DDR2 Memory */
    boot_dsp_from_arm( 0x80000000 );
}
