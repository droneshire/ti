{
  "_args": [
    [
      {
        "raw": "secure-peer@~0.2.1",
        "scope": null,
        "escapedName": "secure-peer",
        "name": "secure-peer",
        "rawSpec": "~0.2.1",
        "spec": ">=0.2.1 <0.3.0",
        "type": "range"
      },
      "/home/auser/src/ti-rex-core/node_modules/seaport"
    ]
  ],
  "_from": "secure-peer@>=0.2.1 <0.3.0",
  "_id": "secure-peer@0.2.1",
  "_inCache": true,
  "_location": "/secure-peer",
  "_npmUser": {
    "name": "substack",
    "email": "mail@substack.net"
  },
  "_npmVersion": "1.3.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "secure-peer@~0.2.1",
    "scope": null,
    "escapedName": "secure-peer",
    "name": "secure-peer",
    "rawSpec": "~0.2.1",
    "spec": ">=0.2.1 <0.3.0",
    "type": "range"
  },
  "_requiredBy": [
    "/seaport"
  ],
  "_resolved": "http://registry.npmjs.org/secure-peer/-/secure-peer-0.2.1.tgz",
  "_shasum": "c5a4c3789c03945555c2a650db3b47a9c1acc4a7",
  "_shrinkwrap": null,
  "_spec": "secure-peer@~0.2.1",
  "_where": "/home/auser/src/ti-rex-core/node_modules/seaport",
  "author": {
    "name": "James Halliday",
    "email": "mail@substack.net",
    "url": "http://substack.net"
  },
  "bugs": {
    "url": "https://github.com/substack/secure-peer/issues"
  },
  "dependencies": {
    "event-stream": "~3.0.7",
    "inherits": "~1.0.0",
    "through": "~1.1.1"
  },
  "description": "peer-to-peer encrypted streams using public key cryptography and signing",
  "devDependencies": {
    "tap": "~0.3.0"
  },
  "directories": {
    "example": "example",
    "test": "test"
  },
  "dist": {
    "shasum": "c5a4c3789c03945555c2a650db3b47a9c1acc4a7",
    "tarball": "https://registry.npmjs.org/secure-peer/-/secure-peer-0.2.1.tgz"
  },
  "homepage": "https://github.com/substack/secure-peer",
  "keywords": [
    "crypto",
    "diffie-hellman",
    "rsa",
    "encryption"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "substack",
      "email": "mail@substack.net"
    }
  ],
  "name": "secure-peer",
  "optionalDependencies": {},
  "readme": "# secure-peer\n\nCreate encrypted peer-to-peer streams using public key cryptography and signing.\n\nNo certificates, no authorities. Each side of the connection has the same kind\nof keys so it doesn't matter which side initiates the connection.\n\n[![build status](https://secure.travis-ci.org/substack/secure-peer.png)](http://travis-ci.org/substack/secure-peer)\n\n# example\n\nFirst generate some public/private keypairs with\n[rsa-json](http://github.com/substack/rsa-json):\n\n```\n$ rsa-json > a.json\n$ rsa-json > b.json\n```\n\n``` js\nvar secure = require('secure-peer');\nvar peer = secure(require('./a.json'));\nvar through = require('through');\n\nvar net = require('net');\nvar server = net.createServer(function (rawStream) {\n    var sec = peer(function (stream) {\n        stream.pipe(through(function (buf) {\n            this.emit('data', String(buf).toUpperCase());\n        })).pipe(stream);\n    });\n    sec.pipe(rawStream).pipe(sec);\n});\nserver.listen(5000);\n```\n\n``` js\nvar secure = require('secure-peer');\nvar peer = secure(require('./b.json'));\n\nvar net = require('net');\nvar rawStream = net.connect(5000);\n\nvar sec = peer(function (stream) {\n    stream.pipe(process.stdout);\n    stream.end('beep boop\\n');\n});\nsec.pipe(rawStream).pipe(sec);\n\nsec.on('identify', function (id) {\n    // you can asynchronously verify that the key matches the known value here\n    id.accept();\n});\n```\n\nFor extra security, you should keep a file around with known hosts to verify\nthat the public key you receive on the first connection doesn't change later\non like how `~/.ssh/known_hosts` works.\n\nMaintaining a known hosts file is outside the scope of this module.\n\n# methods\n\n``` js\nvar secure = require('secure-peer')\n```\n\n## var peer = secure(keys, opts={})\n\nReturn a function to create streams given the `keys` supplied.\n\n`keys.private` should be a private PEM string and `keys.public` should be a\npublic PEM string.\n\nYou can generate keypairs with [rsa-json](http://github.com/substack/rsa-json).\n\nYou can set a preference ordering array of ciphers to use with `opts.ciphers`.\nBoth sides will use a deterministic ordinal voting algorithm to determine which\ncipher to use.\nSee `openssl list-cipher-algorithms` for the whole list.\n\n## var sec = peer(cb)\n\nCreate a new duplex stream `sec` that caries the encrypted contents. This stream\nis safe to stream over the wire, including untrusted networks.\n\n`cb` is a shorthand to listen on the `'connection'` event just like\n`net.createServer()`.\n\n# events\n\n## sec.on('connection', function (stream) {})\n\nEmitted with the decrypted plaintext stream when the secure connection has been\nestablished successfully.\n\n`stream.id` is the identify object from the `'identify'` event.\n\n## sec.on('identify', function (id) {})\n\nEmitted when the connection identifies with its public key, `id.key`.\n\nEach listener *must* call either `id.accept()` or `id.reject()`.\n\nThe connection won't be accepted until all listeners call `id.accept()`. If any\nlistener calls `id.reject()`, the connection will be aborted.\n\n### id.accept()\n\nAccept the connection. This function must be called for every listener on the\n`'identify'` event for the connection to succeed.\n\n### id.reject()\n\nReject the connection. The connection will not succeed even if `id.accept()` was\ncalled in another listener.\n\n## sec.on('header', function (header) {})\n\nEmitted when the remote side provides a signed header.payload json string signed\nwith its private key in header.hash.\n\n# install\n\nWith [npm](https://npmjs.org) do:\n\n```\nnpm install secure-peer\n```\n\n# license\n\nMIT\n",
  "readmeFilename": "readme.markdown",
  "repository": {
    "type": "git",
    "url": "git://github.com/substack/secure-peer.git"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "version": "0.2.1"
}
