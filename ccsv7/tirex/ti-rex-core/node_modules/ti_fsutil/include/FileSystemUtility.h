/*
 * Copyright (c) 2015, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * */
// FileSystemUtility.h

#ifndef FSUTIL_FILESYSTEMUTILITY_H
#define FSUTIL_FILESYSTEMUTILITY_H

#include "fsutil/FSUtilExport.h"

class FSUtil
{
public:
	//////////////////////////////////////////////////////////////////////////
	// Clean the AppData cache for _this_ install of CCS
	virtual void Clean( bool bCleanAll ) const =0;


	//////////////////////////////////////////////////////////////////////////
	// Get a writable directory to store data for this application:
	//
	//	- The folder will be automatically created if it does not already exist.
	//	- If multiple copies of CCS are installed, each will have it's own directory
	//  - The folder will be re-used on subsequent runs, but will be unique per running process
	//     - A second CCS process will get a new, empty folder
	//     - Use Get_SharedTemporaryFile_Dir() to get a folder that is shared between running processes
	//
	// On Windows, this method will return the "short" (8 dot 3) path.  This is essential
	// because CSIDL_LOCAL_APPDATA may contain wide-characters.  The registry flag 
	// "NtfsDisable8dot3NameCreation" must not be set to ensure this works.
	//
	// **NOTE:  If a writable AppDataDir cannot be calculated then this method will return the InstallDir **
	//
	const char* Get_AppData_Dir() const
	{
		// Inline version with original name to maintain backwards compatibility
		return Get_TemporaryFile_Dir();
	}
	virtual const char* Get_TemporaryFile_Dir() const =0;			// Returned value does not have a trailing slash


	// Get the full path this application's installation directory ( <INSTALLDIR> ).
	virtual const char* Get_Install_Dir() const =0;			// Returned value does not have a trailing slash


	// Get the 'base' directory that contains all of the 'native' (as opposed to Java) content.
	// For CCS v4 this will be <INSTALLDIR/ccsv4>
	// For CCS v5 this will be <INSTALLDIR/ccsv5/ccs_base_XX.XX.XX.XX>
	virtual const char* Get_Base_Dir() const =0;			// Returned value does not have a trailing slash


	// Get the directory that contains all of the common (shared) binaries
	// For CCS v4 this will be <INSTALLDIR/ccsv4/common/bin>
	// For CCS v5 this will be <INSTALLDIR/ccsv5/ccs_base_XX.XX.XX.XX/common/bin>
	virtual const char* Get_CommonBin_Dir() const =0;		// Returned value does not have a trailing slash


	// Get the directory that contains the DebugServer binaries:
	// For CCS v4 this will be <INSTALLDIR/ccsv4/DebugServer/bin>
	// For CCS v5 this will be <INSTALLDIR/ccsv5/ccs_base_XX.XX.XX.XX/DebugServer/bin>
	virtual const char* Get_DebugServerBin_Dir() const =0;	// Returned value does not have a trailing slash


	// Get the XPCOM directory:
	// For CCS v4 this will be <INSTALLDIR/ccsv4/DebugServer/bin>
	// For CCS v5 this will be <INSTALLDIR/ccsv5/ccs_base_XX.XX.XX.XX/DebugServer/bin>
	virtual const char* Get_XPCOM_Dir() const =0;			// Returned value does not have a trailing slash


	//////////////////////////////////////////////////////////////////////////
	// These convenience methods are designed to make it simpler to work
	// with pathnames.  Automatically handles leading and trailing slashes,
	// path normalization (turning c:\aaaa\bbbb\..\cccc\dddd into c:\aaaa\cccc\dddd)
	// and prevents the general headaches associated with concatenating pathnames as strings.


	// Append the path 'additional' to the specified directory. AppDataDir and return the result in 'buffer'
	// If 'buffer' is too small to hold the resulting path it will be truncated.
	// Return the size to hold the resulting path (plus the terminating NULL character)
	virtual unsigned int AppendToDir(const char* path, const char* additional, char *buffer, unsigned int bufferSize) const =0;


	// Create the specified directory (does nothing if path already exists)
	virtual void MakeDirectory(const char* path) const =0;


	// Create the specified empty file (does nothing if file already exists)
	virtual void MakeFile(const char* path) const =0;


	// Return true if the specified path exists
	virtual bool Exists(const char* path) const =0;


	// Return true if the specified path exists and is a directory
	virtual bool IsDirectory(const char* path) const =0;


	// Return true if the specified path exists and is a file (not a symlink)
	virtual bool IsFile(const char* path) const =0;


	// Construct the name of a shared library based on the specified root and return the result in 'buffer'
	// If 'buffer' is too small to hold the resulting path it will be truncated.
	// Return the size to hold the resulting path (plus the terminating NULL character)
	// For example:  if root is "Foo" will return "libFoo.so" on Linux and "Foo.dll" on windows
	virtual unsigned int SharedLibrary(const char* root, char *buffer, unsigned int bufferSize) const =0;
	

	// Construct the name of an executable based on the specified root and return the result in 'buffer'
	// If 'buffer' is too small to hold the resulting path it will be truncated.
	// Return the size to hold the resulting path (plus the terminating NULL character)
	// For example:  if root is "Foo" will return "Foo" on Linux and "Foo.exe" on Windows
	virtual unsigned int Executable(const char* root, char *buffer, unsigned int bufferSize) const =0;


	// Return the path separator
	virtual const char* PathSeparator() const =0;
	

	// Return the Environment Variable separator
	virtual const char* EnvSeparator() const =0;


	//////////////////////////////////////////////////////////////////////////
	// FSUtil implements "Advisory Locking".  The operating system maintains
	// a list of files that have been locked, but does not prevent reading or
	// writing to a "locked" file.  Any process can ignore an advisory lock.
	//
	// This means that advisory locks are for cooperating  processes, processes
	// that can trust each other.
	//
	// The Lock on a file is 'reference counted' - so take care to lock and unlock
	// the same number of times.  To simplify locking use the class 'FSLock' 
	// defined in <FileSystemLock.h>.
	//
	// A locked file is automatically unlocked when the process exits.
	//
	// Limitations:
	//
	//	1) Ideally, lock a file only once per process.  Multiple locks will
	//  increment the lock ref-count
	//
	//	2) Use the same thread to lock and unlock a file.
	//
	//  3) If you are using a std::fstream or native file handle to write to the file while using
	//  file locks on that file, release all locks on the file before closing the file.


	// Lock the specified file. If another process already has ownership of the lock,
	// this thread will block until it can obtain the ownership.  
	// 
	// If the specified file does not exist then this method will do nothing and return immediately.
	virtual void Lock( const char* filename ) =0;


	// Unlock the specified file.  It the file cannot be unlocked (i.e. file does not exist) or
	// file was not locked then this method does nothing.
	virtual void Unlock( const char* filename ) =0;

	// The following 2 functions were added to the bottom of the dll in newer 
	// versions.  However, to make everything typesafe, I've marked them 
	// protected.  The newer FSUtil2 exposes them publicly.  
	// 
	// Marking them protected keeps the vtable the same for backwards 
	// compatibility.  Clients caring about that can use the new FSUtil2 and know
	// that the functions are valid.  Clients not caring can use an old header
	// and safely call these functions, but then aren't backwards compatible.

protected:

	// See Get_TemporaryFile_Dir for details
	// Added in CCS 5.1
	virtual const char* Get_SharedTemporaryFile_Dir() const =0;			// Returned value does not have a trailing slash

	// This is a path to store configuration files.  This location is not 
	// unique per process or install, but is unique per user.  As such, files
	// stored here must be locked appropriately in case multiple processes are 
	// running, and the format must be compatible with past/future releases.
	// Added in CCS 5.2
	virtual const char* Get_ConfigurationFile_Dir() const =0;

protected:
	
	inline virtual ~FSUtil() {};	// Intentionally Blank
};

// FSUtil interface with additional functionality
// Added in CCS 5.5
class FSUtil2 : public FSUtil
{
public:

	virtual const char* Get_SharedTemporaryFile_Dir() const =0;
	virtual const char* Get_ConfigurationFile_Dir() const =0;

protected:

	inline virtual ~FSUtil2() {};
};

// FSUtil interface with additional functionality
// Added in CCS 6.0
class FSUtil3 : public FSUtil2
{
public:

	// Returns a location for files that are common across all users/installs
	virtual const char* Get_GlobalFile_Dir() const =0;

	// The location where dump files are stored
	virtual const char* Get_DumpFile_Dir() const =0;

	// The location where dump files for unresponsiveness are stored
	virtual const char* Get_UnresponsiveDumpFile_Dir() const =0;

protected:

	inline virtual ~FSUtil3() {};
};

FSUTIL_EXPORT_IMPORT FSUtil& CreateFSUtil();
FSUTIL_EXPORT_IMPORT FSUtil2& CreateFSUtil2();
FSUTIL_EXPORT_IMPORT FSUtil3& CreateFSUtil3();

#endif // FSUTIL_FILESYSTEMUTILITY_H
