/*
 * Copyright (c) 2015, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * */
#include <v8.h>
#include <node.h>
#include <iostream>
#include <exception>
#include <stdlib.h>
#include <string>

#include "FileSystemUtility.h"
#include "FileSystemUtility_c.h"
using namespace v8;

#define ENABLE_DEBUG 0
#if _WIN32 || _WIN64
#include <windows.h>
#include <tchar.h>
#if _WIN32
#define PATH_TO_DLL "node_modules\\ti_fsutil\\lib\\win32\\fsutil.dll"
#else
#define PATH_TO_DLL "node_modules\\ti_fsutil\\lib\\win64\\fsutil.dll"
#endif
#else
#if DARWIN
#define PATH_TO_DLL "node_modules\\ti_fsutil\\lib\\mac\\libfsutil.so"
#else
#define PATH_TO_DLL "node_modules\\ti_fsutil\\lib\\linux32\\libfsutil.so"
#endif
#endif
std::string path(PATH_TO_DLL);
//path.append("\\dll_name.dll");

void debugPrint(const char* fmt){
#if (ENABLE_DEBUG)
	printf(fmt);
#endif
}   

void debugPrintStr(const char* fmt, const char* str){
#if (ENABLE_DEBUG)
	printf(fmt,str);
#endif
}   

void debugPrintLong(const char* fmt, long adrs){
#if (ENABLE_DEBUG)
	printf(fmt, adrs);
#endif
}   

typedef void (* OverrideInstall_Dir)(const char*);
typedef const char* (* Get_GlobalFile_Dir)();
typedef const char* (* Get_TemporaryFile_Dir)();
typedef const char* (* Get_SharedTemporaryFile_Dir)();
typedef  FSUtil3& (* Create_FSUtil3_Obj)();

static bool isInitialized = false;
#if _WIN32 || _WIN64	
static HINSTANCE hDLL = NULL;
#else
static void* hDLL = NULL;
#endif

static std::string appNameTag ("Default_TI_nwApp");
//static void* fsutil;
static FSUtil3 *pFSUtil3;
void initDll();

void initDll(){
#if _WIN32 || _WIN64
	OverrideInstall_Dir _overrideInstallDir;
	Create_FSUtil3_Obj _createFSUtil3Func;    // Function pointer

	if (!isInitialized){
	    debugPrintStr("\ninitDll: isInitialized=false, path to library = %s",path.c_str());	

        hDLL = LoadLibrary(path.c_str());

		if (hDLL){
			_overrideInstallDir = (OverrideInstall_Dir)GetProcAddress(hDLL,"FSUtil_Override_Install_Dir");

			debugPrintLong("\n_overrideInstallDir = 0x%x\n",(long)_overrideInstallDir);

			_overrideInstallDir(appNameTag.c_str());
			
			_createFSUtil3Func = (Create_FSUtil3_Obj)GetProcAddress(hDLL,"CreateFSUtil3");			
			pFSUtil3 = &_createFSUtil3Func();	

			isInitialized = true;
		}	
	}
#else
   isInitialized = true;
#endif	

}

// See http://msdn.microsoft.com/en-us/library/aa364963.aspx for more info
Handle<Value>  getShortPathName(const Arguments &args) {
	HandleScope scope;
	std::string longPathName;
#define BUFSIZE 4096
#if _WIN32 || _WIN64
	TCHAR  buf[BUFSIZE]=TEXT(""); 
	DWORD retval=0;
#endif	
	if (args.Length() < 1) {
       ThrowException(Exception::TypeError(String::New("Wrong number of arguments (should be 1)")));
       return scope.Close(Undefined());
    }
	 // get the param
    v8::String::Utf8Value param1(args[0]->ToString());

    // convert it to string
    longPathName = *param1;    
	debugPrintStr("\nEntering getShortPathName(%s)...",longPathName.c_str());	
#if _WIN32 || _WIN64
	retval = GetShortPathName(longPathName.c_str(), buf, BUFSIZE);

	if (retval == 0){
		debugPrintLong("\ngetShortPathName failed (%d)",GetLastError());
		return scope.Close(String::New(longPathName.c_str()));
	} else {
		debugPrintStr("\ngetShortPathName returned %s",buf);
		return scope.Close(String::New(buf));
	}
#else
    return scope.Close(String::New(longPathName.c_str()));
#endif
}

Handle<Value>  setAppNameTag(const Arguments &args) {
	HandleScope scope;
	debugPrint("\nEntering setAppNameTag...");	
	if (args.Length() < 1) {
       ThrowException(Exception::TypeError(String::New("Wrong number of arguments (should be 1)")));
       return scope.Close(Undefined());
    }
	 // get the param
    v8::String::Utf8Value param1(args[0]->ToString());

    // convert it to string
	debugPrintStr("\nappNameTag changed from %s",appNameTag.c_str());
    appNameTag = *param1;    
	debugPrintStr("\nappNameTag set to %s",appNameTag.c_str());
	return scope.Close(Undefined());
}

Handle<Value>  setPathToDll(const Arguments &args) {
	HandleScope scope;
	if (args.Length() < 1) {
       ThrowException(Exception::TypeError(String::New("Wrong number of arguments (should be 1)")));
       return scope.Close(Undefined());
    }
    // get the param
    v8::String::Utf8Value param1(args[0]->ToString());
	debugPrintStr("\norig path= %s",path.c_str());
    path.assign(*param1);
	debugPrintStr("\npath changed to %s",path.c_str());
#if _WIN32 || _WIN64
    if (isInitialized && hDLL){
		FreeLibrary(hDLL);
		hDLL = NULL;
		isInitialized = false;
	}
#endif
	return scope.Close(Undefined());
}

Handle<Value> getErrorFromLoadLibrary(const Arguments& args) {
	HandleScope scope;
#if _WIN32 || _WIN64	
	HINSTANCE _hDLL;
	DWORD dError;
	debugPrintStr("\ngetErrorFromLoadLibrary: path to library = %s",path.c_str());	

    _hDLL = LoadLibrary(path.c_str());
	if(_hDLL){
		FreeLibrary(_hDLL);
		return scope.Close(Integer::New(0));
	}else{
	/*
	 * Error 126 : Could not locate the dll file. To debug this, use the 
	 * Microsoft Process Monitor, which can be  downloaded from 
     * http://technet.microsoft.com/en-us/sysinternals/bb896645
     * - Stop event capture, then clear events, then run node test.js, 
	 * - then stop events, then filter for fsutil.dll to find out where the 
	 *   OS thought the DLL should have been found.
	 *
     * Error 193: "Not a valid Win32 application" 
	 * For node.js on Windows7, you need to use the win64 version of the dll
     * For node-webkit on Windows7, you need to use the win32 version of the dll
     */
		dError = GetLastError();
		return scope.Close(Integer::New((int)dError));
	}
#else
	return scope.Close(Integer::New(-1));
#endif
}



Handle<Value>  getConfigFileDir(const Arguments &args) {
	HandleScope scope;

	initDll();
	if (hDLL){
			const char* dirName = pFSUtil3->Get_ConfigurationFile_Dir();
			if (dirName == NULL){
				debugPrint("\ndirName = NULL");
			} else {
				debugPrintStr("\ndirName = %s",dirName);
			}

			return scope.Close(String::New(dirName));
	} else {
		return scope.Close(String::New(""));
	}
}

Handle<Value> getGlobalFileDir(const Arguments &args) {
	HandleScope scope;
		initDll();
		if (hDLL){
			const char* dirName = pFSUtil3->Get_GlobalFile_Dir();
			if (dirName == NULL){
				debugPrint("\nGlobalDirName = NULL");
			} else {
				debugPrintStr("\nGlobalDirName = %s",dirName);
			}

			return scope.Close(String::New(dirName));
	} else {
		return scope.Close(String::New(""));
	}			
}

Handle<Value> getSharedTemporaryFileDir(const Arguments &args) {
	HandleScope scope;
	initDll();

	if (hDLL){
			const char* dirName = pFSUtil3->Get_SharedTemporaryFile_Dir();
			if (dirName == NULL){
				debugPrint("\nSharedTemporaryFileDir = NULL");
			} else {
				debugPrintStr("\nSharedTemporaryFileDir = %s\n",dirName);
			}

			return scope.Close(String::New(dirName));
	} else {
		return scope.Close(String::New(""));
	}

}

Handle<Value>  getTemporaryFileDir(const Arguments &args) {
	HandleScope scope;

	initDll();

	if (hDLL){
			const char* dirName = pFSUtil3->Get_TemporaryFile_Dir();
			if (dirName == NULL){
				debugPrint("\nTemporaryFileDir = NULL");
			} else {
				debugPrintStr("\nTemporaryFileDir = %s\n",dirName);
			}

			return scope.Close(String::New(dirName));	
	} else {
		return scope.Close(String::New(""));
	}

}

Handle<Value>  getDumpFileDir(const Arguments &args) {
	HandleScope scope;

	initDll();

	if (hDLL){
			const char* dirName = pFSUtil3->Get_DumpFile_Dir();
			if (dirName == NULL){
				debugPrint("\nDumpFileDir = NULL");
			} else {
				debugPrintStr("\nDumpFileDir = %s",dirName);
			}

			return scope.Close(String::New(dirName));	
	} else {
		return scope.Close(String::New(""));
	}

}




extern "C" {
static void Init(Handle<Object> target) {
	HandleScope scope;

	Handle<FunctionTemplate> setPathToDllTpl =
			FunctionTemplate::New(setPathToDll);

	target->Set(String::New("setPathToDll"),
			setPathToDllTpl->GetFunction());
			
	Handle<FunctionTemplate> setAppNameTagTpl =
			FunctionTemplate::New(setAppNameTag);

	target->Set(String::New("setAppNameTag"),
			setAppNameTagTpl->GetFunction());
			
	Handle<FunctionTemplate> getErrorFromLoadLibraryTpl =
			FunctionTemplate::New(getErrorFromLoadLibrary);

	target->Set(String::New("getErrorFromLoadLibrary"),
			getErrorFromLoadLibraryTpl->GetFunction());

	Handle<FunctionTemplate> getGlobalFileDirTpl =
			FunctionTemplate::New(getGlobalFileDir);

	target->Set(String::New("getGlobalFileDir"),
			getGlobalFileDirTpl->GetFunction());

	Handle<FunctionTemplate> getTemporaryFileDirTpl =
			FunctionTemplate::New(getTemporaryFileDir);

	target->Set(String::New("getTemporaryFileDir"),
			getTemporaryFileDirTpl->GetFunction());

	Handle<FunctionTemplate> getSharedTemporaryFileDirTpl =
			FunctionTemplate::New(getSharedTemporaryFileDir);

	target->Set(String::New("getSharedTemporaryFileDir"),
			getSharedTemporaryFileDirTpl->GetFunction());
			
	Handle<FunctionTemplate> getConfigFileDirTpl =
			FunctionTemplate::New(getConfigFileDir);

	target->Set(String::New("getConfigFileDir"),
			getConfigFileDirTpl->GetFunction());			


	Handle<FunctionTemplate> getDumpFileDirTpl =
			FunctionTemplate::New(getDumpFileDir);

	target->Set(String::New("getDumpFileDir"),
			getDumpFileDirTpl->GetFunction());

	Handle<FunctionTemplate> getShortPathNameTpl =
			FunctionTemplate::New(getShortPathName);

	target->Set(String::New("getShortPathName"),
			getShortPathNameTpl->GetFunction());			
}
NODE_MODULE(ti_fsutil, Init)
}
