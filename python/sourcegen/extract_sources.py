#!/usr/bin/python
"""
This script parses the subdif_rules file generated by CCS project creation
and outputs a nearly identical rules makefile with correct path location.

This is necessary b/c their generated output uses the windows toolchain location,
and outputs all files in terms of absolute path in windows format
"""
import re
import os
import argparse

INPUT_FILES=['subdir_rules.mk', 'subdir_vars.mk', 'objects.mk', 'sources.mk']
SRCGEN_PREFIX='gen_'

BUILD_DIR= 'build'
PROJECTS_DIR= 'projects'
TI_ROOT = '../../'

def save(filename, txt):
    with open(filename, 'w') as f:
        f.write(txt)
        f.close()

def load(filename):
    with open(filename, 'r') as f:
        t = f.read()
        f.close()
        return t

def find_source_file(name, path):
    for root, dirs, files in os.walk(path):
        if name in files:
            return os.path.join(root, name)

def create_makefile(source_text, ti_root):
	output_text = ""
	relative_path_pattern = ['\.\..(*\.c)', '\.\..(*\.asm)']
	ti_path_pattern = ['\D:/[^\s]*?[^controlSUITE]', '\D:/[^\s]*?[^motorware]', '\D:/[^\s]*?[^ccsv7]']
	ti_path_pattern = '|'.join(ti_path_pattern)
	relative_path_pattern = '|'.join(relative_path_pattern)
	pattern = re.compile(ti_path_pattern)

	for line in source_text:
		# Search for Windows style path
		l = pattern.sub(ti_root, line)
		# Remove reference to cmd.exe
		l = re.sub(r'SHELL.*', '', l)
		# Remove all invalid compiler flags
		l = re.sub(r'--cdebug_asm_data', '', l)
		# Replace all relative directory '..' to '.'
		output_text += re.sub(r'--output_all_syms', '', l) + '\n'


	return output_text

def run(project_name):
	ti_root_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), TI_ROOT))
	project_dir = os.path.join(ti_root_dir, PROJECTS_DIR, project_name[0])

	print project_dir

	if os.path.isdir(project_dir):
		print 'Parsing {} for sources'.format(project_name)

		for in_file in INPUT_FILES:
			# We find the file b/c it can be located in different folders based on
			# project setup
			source_makefile = find_source_file(in_file, project_dir)

			if os.path.isfile(source_makefile):
				print 'Found {}...'.format(in_file)

				out_text = create_makefile(load(source_makefile).split('\n'), ti_root_dir)

				save(os.path.join(project_dir, BUILD_DIR, SRCGEN_PREFIX + in_file), out_text)
				print 'Generated {}'.format(SRCGEN_PREFIX + in_file)
			else:
				print 'Could not find {}}, aborting...'.format(in_file)

	else:
		print 'Invalid project'

if __name__ == '__main__':
	parser = argparse.ArgumentParser(description='Creates a makefile with rules to build all sources for a given project')
	parser.add_argument('project', nargs=1, type=str, help='Projects that should have a makefile generated')
	args = parser.parse_args()

	run(args.project)